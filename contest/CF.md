$\newcommand{\lr}[3]{\left#1 #3 \right#2}$ 

#### Codeforces Round #773 (Div. 1)

[link](https://codeforces.com/contest/1641). 

##### *C. Anonymity Is Important

${\cal O}(n \log ^2 n)$ 遗憾 TLE。

先拿一个 `set` 维护所有不确定的位置，那么 $0$ 修改直接暴力即可，均摊为 ${\cal O}(n \log n)$，对于一修改，直接在 $[l, r]$ 内第一个不确定的位置打标记 $r$，若下一个不确定就超过了，那可以直接确定，否则在 $0$ 操作的时候，删掉一个不确定的，标记向后平移一次，然后考虑区间前第一个和区间后第一个是否已经确定即可，至于如果打多次标记，只需要取最小值即可。

时间复杂度 ${\cal O}(n \log n)$。

##### *D. Two Arrays

可以先将所有数组按照 $w$ 排序，然后枚举其中的一个数组。

考虑另一个数组需要满足的是不交并且权值最小，那么对每个值维护一个 `bitset` 表示包含这个值的集合，那么扫描这个数组内的所有元素，把对应集合求并，那么第一个 $0$ 代表的数组就是不交的最小元素。

时间复杂度 ${\cal O}\lr(){nm \dfrac{n}{\omega}}$。

但是空间复杂度很高，然而注意到，很多 `bitset` 可能是空的，即使有的，可能也只有 $1, 2$ 个，实在是浪费。

考虑设定一个阈值 $T = 1000$，若一个元素对应的集合不超过 $T$，那么可以暴力求并，不需要使用 `bitset`，而由于鸽笼原理，需要 `bitset` 的很少，此时空间符合要求，时间符合要求。

还有一种 ${\cal O}(n 2^m)$ 的做法。

考虑如何判断两个集合 $S, T$ 是否有重合元素。

考虑先把 $S$ 的 $2^m$ 个子集写出来，接下来看 $T$ 的所有子集，若出现在 $S$ 的子集中，那么贡献 $(-1)^{|s|}$。

可以发现贡献集合一定是 $S \cap T$ 的子集，贡献是 $\sum_{i=0}^{|S\cap T|} \binom{|S \cap T|}{i} (-1)^i$，逆用二项式定理，也就是 $(-1 + 1) ^ {|S \cap T|}$，那么交集为空则答案为 $1$，否则 $0$。

先按 $w$ 排序数组，然后拿一个 `trie`，转移边用 `map` 维护，加入一个数组的时候暴力枚举所有子集去加入，查询的时候查询所有子集对应的和，从前往后加入，若 `get_cnt(i) != 0`，说明 $i$ 和前面的某个构成合法对，拿一个指针从后往前删除回去即可，这样我们找到了一对 $(j, i)$ 满足不交，并且 $j$ 不能再小了，否则 $(k, i)$ 无法构成匹配。

注意到 $i$ 不能再小了，再小一定没有匹配，于是让 $i$ 逐渐往上跑，如果 $j$ 也往上走一定不优，若 $i$ 增加后，$j - 1$ 或者之前多出了匹配，那就删除 $j$，让 $j$ 逐渐往前走即可，指针总移动次数是 ${\cal O}(n)$ 的。

复杂度为 ${\cal O}(n 2^m)$。

