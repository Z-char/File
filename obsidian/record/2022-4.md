# 4.2

### Luogu#4219. 大融合

[luogu#4219](https://www.luogu.com.cn/problem/P4219). 

题目大意：

给定 $n$ 个点，你需要维护两种操作：

1. 加边，保证加边后原图仍然是森林。
2. 询问 $(x, y)$ 这条边两边 size 乘积，保证边存在。

$n \le 10^5$。

---

动态连边考虑 lct，由于要维护子树信息，考虑对虚儿子整体维护信息，其实这很类似 ddp。

直接维护 `siz[x], siz2[x]` 分别表示真正的 siz 和虚儿子 siz，剩下的我也不知道怎么讲了，你就对着 lct 的板子改一改，需要切换虚实的时候维护一下就行了。

[Submission(0)](https://loj.ac/s/1430219). 

在调试 rotate 的那个 bug 时(代码中已注明)，我确信看到了 0 有父亲并且 0 的 siz 是 1 过，虽然我不知道他的 siz 是什么时候更新的，但是就算不清空 0 节点也可以通过，不过还是清空更为保险一点(

# 4.3

### Luogu#6240. 好吃的题目

题目大意：

多次询问，区间背包。

$n \le 4 \times 10^4, m \le 2 \times 10^5, h_i, t_i \le 200, w_i \le 10^7$。

~~相信大家都猜到了~~，$n, m$ 分别表示物品个数以及询问个数，$h, w$ 分别表示体积和价值，$t$ 表示每次询问的背包大小。

---

只需要离线分治就行了，感觉这题想到分治就结束了，分治背包，对于每个分治区间，跑前后缀，对于被其分割的询问，直接回答，总复杂度为 ${\cal O}(tn \log n + qt)$，空间复杂度大概可以优化到 ${\cal O}(m + nt)$。

并不明白为什么空间爆掉了。

### SP#1812. LCS2

[sp#1812](https://www.luogu.com.cn/problem/SP1812). 

题目大意：

泻药，多串求最长公共子串。

$n \le 10, |s_i| \le 10^5$。

时间限制：236ms。

空间限制：1.46G。

---

这时空限制略显诡异啊？

考虑使用 sam，我们挑一个最短的串建立 sam，接下来拿所有串在上面跑，如果匹配失败了就跳 fail 指针，并重置当前匹配长度为跳到的点的 `len`，然后对于每个节点记录最大 len，然后注意到一个等价类如果可以被匹配到，则 fail 里的串都可以被匹配到，所以在子树里再取 max，最后对自己的长度取 min，这样就得到了这个串匹配每个节点的最大值，对于所有串的结果取 min，然后取全局 max 就好了。

> 如果不好理解的话可以理解为 sam 其实是一个串所有子串的 ac 自动机。

至于时间复杂度，每次跳 fail 相当于至少除去前面一个字符，考虑 kmp 的想法就是了，所以总复杂度是 $\sum |s_i|$ 的。

[Submission(?)](https://www.luogu.com.cn/record/73067104). 

### CF#710F. String Set Queries

[cf#710f](https://www.luogu.com.cn/problem/CF710F). 

题目大意：

维护一个字符串集合，要求支持三种操作：

1. 集合中加入一字符串。
2. 集合中删除一字符串。
3. 给出一字符串，查询集合里所有字符串在模板串里出现的次数和。

**强制在线**。

$m \le 3 \times 10^5, \sum |s_i| \le 3 \times 10^5$。

时间限制：3s。

空间限制：750M。

---

先考虑静态问题，要求串长复杂度，那就对所有文本串建立 ac 自动机，然后 dfs fail 树求出匹配每个节点的贡献，然后模式串暴力在 ac 自动机上跑，求走到的节点权值和即可。

考虑这个问题，事实上加字符串和删除字符串可以看成一种操作，一种 endpos 贡献 1 一种 endpos 走到之后贡献 -1 而已，所以现在只剩下加入字符串和查询了。

如果这个问题可以离线就好了！因为我们现在的问题其实满足：如果修改都在询问之前我们会做，修改对询问的贡献是独立的。我们可以考虑 cdq 分治，每次把左边的串建立 ac 自动机，右边的询问串跑，每个串只会被加入 $\log$ 次 ac 自动机，每个串只会查询 $\log$ 次，这就做完了！

事实上，满足这样性质的问题并不只能 cdq，我们可以用二进制分组做到在线 cdq 分治。

以本题为例，具体的，我们维护 $\log$ 个 ac 自动机，每次查询我们在 $\log$ 个自动机上分别跑，每次加入一个的时候，我们新建自动机，如果这个自动机和上一个自动机串个数相同，我们就合并两个自动机，也就是把串拿出来，重新暴力插入来建立新的自动机。

事实上，有人用线段树来解释这个过程，我们相当于在 $1$ 这个节点加入一个 ac 自动机，然后在 $2$ 加入，一旦有一个节点满足全部被塞满，也就是加入的自动姬个数和区间长度相同，我们就暴力把左右儿子 pushup 上来，我们上面的过程是类似的，只不过由于我们提前不知道线段树长度，我们可以假定这是一个 $2^k$ 长度的二叉树，反正如果不对了，再在后面继续扩展嘛，虽然有一些空节点但是无伤大雅，可以发现每个串被 pushup 的次数只有 $\log$ 次，每个询问拆成的区间也只有 $\log$ 个(线段树嘛)，所以总复杂度是 ${\cal O}(\sum |s_i| \log n)$。

你也可以理解为当 $i$ 次插入时恰好有 $\rm popcount(i)$ 个自动姬，且每个自动姬的大小(串个数)就对应那一位对应的值，进位相当于合并最后一个自动姬和之前的一个自动姬，就行了。

[Submission(1)](https://codeforces.com/contest/710/submission/152576542). 

### LOJ#2197. 向量集

[loj#2197](https://loj.ac/p/2197). 

题目大意：

要求你维护向量集合，支持如下操作：

1. 加入向量 $(x, y)$。
2. 询问 $L, R$ 个加入的向量和 $(x, y)$ 的点积最大值。

**强制在线**。

$n \le 4 \times 10^5$。

时间限制：2s。

空间限制：256M。

---

注意到 $(x, y) \times (z, w) = xz + yw = k$ 这件事稍作变形就可以得到 $z + \dfrac{y}{x} w = \dfrac{k}{x}$，最大化 $k$ 就是最大/最小化右边的柿子，即左边的柿子，事实上，左边的柿子就是经典线性规划，看成 $y + kx = b$ 形式，问题转化为动态加点，每次询问某个斜率的直线切他们，求最大/最小截距(因为除了一个 $x$，我们不知 x 正负)，强制在线。

这里仅讨论求最大截距，那么只会切到上凸壳，如果是静态的，直接维护线段树，每次查询在线段树所有对应节点上二分即可。

这里是强制在线，使用二进制分组，每次节点完全覆盖满之后 pushup 上来，上一题也可以使用这样的方式来做，不过由于询问永远是全局，所以如果 pushup 上来，就可以删掉儿子节点了，所以这道题的做法其实是更为全面，更加强大的，但是上一题那种做法虽然适用范围小，但是更好写，更节省空间时间，如果是全局可以考虑！

[Submission(0)](https://loj.ac/s/1430950). 

### UOJ#191. unknown

[uoj#191](https://uoj.ac/problem/191). 

题目大意：

上一题，不过需要支持新的操作，即撤销最后一次操作。

---

直接套上一题肯定不对，我卡在一个大凸包边缘反复横跳你就爆炸了，考虑更换一下更新条件，每层的某个区间满了，我们就 pushup 这一层的上一个区间，这样每层最多 2 个没有 pushup 的区间，查询复杂度可以保证，如果想逼迫我们重构 $len$ 长度区间，至少要撤销 $len$ 长度，就均摊掉了！赢了！

# 4.4

### ARC#066F. Contest with Drinks Hard

[[2022-3#ARC066D Contest with Drinks Hard|link]]，这里补了一下实现，以及勘误一点：分治过程应该是 $[mid, R]$ 作为右端点贡献到 $[L, mid]$，也就是两边都包含 mid，原因也不难想，考虑左端点合法的右端点范围到底是什么就行了。

代码中的实现是左端点贡献给右端点，附赠一组拍了很久的 hack 数据，另，代码中出现过的 bug 都在代码中注明了，可以看看是否有类似错误。

```
in: 
10
5 6 10 10 5 1 1 6 5 7
5
10 6
8 10
8 6
6 2
7 7

out: 
1
1
1
0
0
```

[Submission(4)](https://atcoder.jp/contests/arc066/submissions/30719248). 

### Luogu#5992. Rozstaw szyn

[luogu#5992](https://www.luogu.com.cn/problem/P5992). 

题目大意：

给你一棵 $n$ 点 $m$ 叶子的树，每个叶子节点有一个权值 $r_i$。

你需要给剩下 $n - m$ 个点分别指定一个权值，使得树上相邻两个点的差的绝对值，求和最小。

$2 \le n \le 5 \times 10^5, m \le n, r_i \le 5 \times 10^5$。

时间限制：1s。

空间限制：125M。

---

设 $f_u(x)$ 表示 $u$ 节点取 $x$ 时子树里的最小代价，儿子的转移形如 $f_v(y) + |x - y| \to f_u(x)$，这实质上相当于 $|x|$ 函数和 $f_v(y)$ 函数做 minkowski sum，然后你对所有儿子求和，由于叶子是凸的，minkowski 之后凸函数仍然是凸的，求和仍然是凸的(对应点相加)，事实上，这个函数就形如一个凸包的样子，于是是可以这么做的(指儿子可以直接 minkowski 因为是凸函数)，然后我们可以直接维护函数，转移就minkowski sum 然后分段函数求和，然而事实上我们只需要维护中间 $k = 0$ 的部分就好了，这是因为转移的时候我们只用到了其与 $|x|$ 的 minkowski sum，你考虑几何意义凸包合并，由于 $|x|$ 无限延伸，所以 minkowski 之后剩下的只会是一个 -1 0 1 斜率的三段函数，而最后求答案显然只需要取中间 0 斜率的部分，于是我们只需要维护中间 0 斜率的高度以及左右端点位置就行了，也就是 **无论转移还是求答案都和边上没关系**。 ^ea4bb3

至于如何求这个，你观察一下就行了，左右端点你发现把儿子的左右端点全部拿出来排序，中间两个对应的线段就是了，因为相当于初始斜率为 $cnt_{son}$，往右扫描，每次增加一个端点斜率 -= 1，所以就不难发现了，用 `nth_element` 可以使总复杂度降为线性，当然你如果使用 `sort` 也无所谓，至于怎么求高度，你都知道不变的区间了，随便选一个端点代入嘛。

[Submission(1)](https://hydro.ac/d/bzoj/record/624cdda1bc977535e24ccd59). 

# 4.6

### Gym#103447L. Karshilov's Matching Problem

[gym#103447l](https://codeforces.com/gym/103447/problem/L). 

题目大意：

给你 $n$ 个模式串，每个串有权值，给你一个文本串，你需要支持下列操作 $m$ 次：

1. 将文本串后缀修改成同一个字符。
2. 对文本串前缀查询 $\sum_{i=1}^n cnt_i \times w_i$，其中 $cnt_i$ 表示前缀中 $i$ 模式串出现次数。

字符集为单个阿拉伯数字，答案取模。

$n \le 10^5, |t_i| \le 10^5, w_i \lt 998244353, |S| \le 3 \times 10^5, m \le 3 \times 10^5, \sum |t_i| \le 10^5$。

时间限制：2s。

空间限制：512M。

---

多少事有点像 [s2oj#266](https://www.sjzezoj.com/problem/266) 的，所以自然可以想到 ac 自动姬上倍增。

显然我们是不能倍增 $S$ 串的，复杂度太高了，但是这题相比那道题的特性就是只会后缀修改，而且 **只有一个字符**，这不是区间推平吗，只有区间推平自然可以想到维护连续段的贡献了(因为区间推平均摊下来对连续段整体的影响是线性级别的)，由于这道题是后缀，那么维护一个单调栈就行了(事实上如果不是后缀就不能这么做了，虽然影响连续段是线性的，但是没法快速维护答案)，考虑一开始我们对于单调栈每个连续段开头的答案都求出来了，并且求出来每个连续段开头会跳到哪里，**注意到字符集只有 10**，可以对 ac 自动姬预处理对每个字符的倍增结果，那么求答案的时候，贰分到连续段开头，倍增过去就好了，修改是容易的，修改位置很少直接求就好了，洒洒水辣！

蚌埠住了，调弱智错误花了半天，然后忘了修改为了调试修改的循环上界又调了半天。

[Submission(1)](https://codeforces.com/gym/103447/submission/152809723) 可能需要 master 以上才能看。

[Code(1)](https://gitee.com/Z_char/pastebin/blob/master/Gym%23103447L.cpp)，我蚌了，开源都要绑定了吗？

[Code(1)](https://github.com/Z-char/pastebin/blob/master/Gym%23103447L.cpp)，github 万岁！可能需要多上几次或者科学一点。

### CF#1616G. Just Add an Edge

[cf#1616g](https://www.luogu.com.cn/problem/CF1616G). 

"你懂了吗？"

“我觉得我懂了”。

于是我不打算详细写了，摸了。

### Gym#103081J. Daisy's Mazes

[gym#103081j](https://codeforces.com/gym/103081/problem/J). 

题目大意：

给你一张 $R$ 个点的图，有 $D$ 条有向边，每条边有颜色，颜色有 $C$ 种，你现在要从 $0$ 走到 $R - 1$，具体的，你的行走方式如下：

1. 如果你的手牌中牌堆顶部为 $s$ 颜色，并且当前所在点有 $s$ 颜色的出边，那你可以任选一个 $s$ 颜色边走，并丢弃顶部手牌。
2. 如果并不匹配或者你没有手牌，你可以任选一个出边，并将这个颜色转化为一张手牌，放入牌堆顶部。

~~可以写成三国杀题面~~。

问你初始最少携带多少手牌，才可以走到目的地。

$2 \le R \le 50, 2 \le D \le 100, 2 \le C \le 20$。

时间限制：3s。

空间限制：256M。

---

主要问题就在于初始牌和走到结尾可能剩下的末尾牌，他的走法并非无迹可寻，事实上可以看出是括号匹配(而且是贪心性质的)，但是初始牌和末尾牌的存在让他的匹配变得十分奇妙，可能你想走的匹配，走到一半被拉走了，可能一些匹配剩到最后没有使用。

官方题解给出了一种非常妙的处理方法，考虑在 0 前面加入 $n - 1$ 个点，每个点向下一个点连所有颜色的边，**这些点间不贪心匹配**，然后让终点连所有颜色的自环，这样从 $-i$ 走到 $n - 1$ 的纯括号匹配路径，就可以对应从牌堆拿出 $i$ 张牌走过去的路径，由于我们是从 `-1` 开始枚举(要求牌堆最小嘛)，所以不会有问题，如果有括号内部匹配了，一定之前就被匹配了，直接做就行了，设 $f(x, y, c)$ 表示提前放个括号 $c$，能否从 $x$ 走到 $y$，且括号匹配，转移就考虑括号匹配外面套括号，以及两段括号拼接就行了，求答案就找一个不存在的颜色来搞即可(这里记颜色是因为括号能否匹配是和上一个括号息息相关的)。

[Submission(3)](https://codeforces.com/gym/103081/submission/152835109). 

[Code(3)](https://github.com/Z-char/pastebin/blob/master/Gym%23103081J.cpp). 

### Gym#103409H. Popcount Words

[gym#103409h](https://codeforces.com/gym/103409/problem/H). 

题目大意：

令 $s_i$ 表示 $\rm popcount(i) \bmod 2$，定义 $w(l, r) = s_ls_{l+1}\ldots s_{r}$。

给出 $S = w(l_1, r_1) + w(l_2, r_2) + \ldots + w(l_n, r_n)$。

接下来有 $q$ 次询问，每次询问给出一个 01 串 $p_i$，询问你 $p_i$ 在 $S$ 中出现多少次。

$n, q \le 10^5, 1 \le l_i \le r_i \le 10^9, \sum |p_i| \le 5 \times 10^5$。

时间限制：1s。

空间限制：512M。

---

首先尝试找找规律，设 $s_i$ 为 $0 \to 2^i - 1$ 对应的 01 串，可以发现 $s_i = s_{i - 1} + \neg s_{i - 1}$，结论不难证明，考虑只是多个首位即可。

那么考虑求出 $p$ 的 ac 自动姬，接下来我们把 $n$ 个串依次在上面跑，具体的，一个串如果用线段树方法，可以拆成若干上面那样的 $s_i$，唯一的区别是 0/1 开头，所以对 ac 自动姬预处理 $f(i, j, 0/1)$ 表示 $i$ 节点，跑 0/1 开头的 $s_j$ 会跑到那里，这样就跑完了，每次跑的时候对这个点打一个标记，即 `tag[i][j][0/1]`，表示这个点跑 $s_{j, 0/1}$ 操作多少次，然后把 tag 下放，就会得到每个点跑 0/1 多少次，这就得到了原串跑 ac 自动姬的结果，然后 fail 树求一下子树和就行了，洒洒水辣！

~~该讲的都讲了，我就不实现了，贺一份~~。

[Code(he)](https://github.com/Z-char/pastebin/blob/master/Gym%23103409H.cpp). 

### AGC#034F. RNG and XOR

[agc#034f](https://www.luogu.com.cn/problem/AT4996). 

题目大意：

给定 $n$ 和长度为 $2^n$ 的数组 $A$(0-index，用于求 $p$ 数组)。

有一个初始为 0 的变量 $x$，每次操作有 $p_i$ 的概率将 $x$ 变成 $x~{\rm xor}~i$，对于所有 $i \in [0, 2^n)$，求出 $x$ 第一次变成 $i$ 的期望步数。

$n \le 18, 1 \le A \le 1000$。

时间限制：3s。

空间限制：1000M。

---

自然的，设 $f_i$ 表示 $i$ 变成 0 的期望步数，有：

$$
f_i = 1 + \sum_{j=0}^{2^n - 1} f_{j~{\rm xor} i} \times p_j
$$

特别的 $f_0 = 0$。

考虑 GF，定义 $\times$ 为 xor 卷积，就有：

$$
F + c = I + F \times P
$$

其中 $c$ 是因为 $f_0$ 不能那么转移而添加的常数修正项。

直接在 xor_FWT 意义下考虑：

$$
\begin{align}
{\rm FWT}(F) + {\rm FWT}(c) = {\rm FWT}(I) + {\rm FWT}(F) \cdot {\rm FWT}(P) \\
\end{align}
$$

注意到 xor_FWT 变换下常数项其实是所有位置系数求和，那么代入 $i = 0$，可以解得 $c = 2^n$。

于是：

$$
{\rm FWT}(F) = \dfrac{\rm FWT({\it c}) - FWT({\it I})}{{\rm FWT}(p) - {\rm FWT}(1)}
$$

直接上一个 fwt 开始求就行了，唯一的问题，当 $i = 0$ 时分母是 0，这可能导致 ifwt 之后常数不为 0，不妨设为 $x$，但是其他位置的计算都是正确的，于是原来那个相当于常数改成 $x$ 做 fwt 的结果，于是 ifwt 之后就把每一项都减掉 $x$ 就可以了。

[Submission(0)](https://atcoder.jp/contests/agc034/submissions/30777215). 

# 4.8

### LOJ#3322. shopping plan

[loj#3322](https://loj.ac/p/3322). 

题目名称来源洛谷。

---

kth 套路就那么些，拿堆胡乱 pop k 次，二分前 k 个，字典序可能还有按位枚举的操作。

这里肯定是拿堆 pop k 次，这类套路的难点在于设置一个后继的指针，以及设置一个简明的状态，一开始的最小值一般比较好找，如果你能设置一个转移，使得度数很小，并且所有状态构成树，并且状态简明转移快速，并且走到一个点权值单调不减，这样总复杂度就最多只有 ${\cal O}(deg \times k \times \text{扩展代价} + k \times \log n)$，并且不重复，并且肯定是按顺序取出来的。

[原来有道题就很充分的体现了这个特点](https://www.sjzezoj.com/problem/1162)。

这道题也是类似的，我们来设置一个简明的状态，具体的，设 $(a, b, c)$ 表示当前和为 $a$，目前考虑到第 $b$ 种类型，这种类型目前取到了第 $c$ 个状态，后继就是当前类型往后走一步，或者走下一个类型，但是走下一个类型和当前状态其实是重复的，感觉可以记录一个 $d$ 表示当前状态是否算数，这样是不重不漏的，相当于是枚举每个类型到底放到哪里，一个一个枚举，但是由于有无用状态我就不知道复杂度对不对了，感觉还是挺对的最多常数乘 2？题解做法事你每次指针向后移动必须强制选一个，但是这样你可能就只能取到 `2 2 2 2 2...` 了，实际可能取 `1 1 1 1...`，所以我们还需要支持一个 `? 2` 变成 `? 1 2` 的操作，为了保证这个操作边权递增，我们需要把所有种类按照第 2 小减去第 1 小排序，就行了。

还剩下一个问题就是如何求某个种类里面的第 $i$ 小权值，其实也类似做就行了，不过由于有 $L \to R$ 这个限制，我的选择是记录四元组，$(a, b, c, d, e)$ 表示当前的和事 $a$，前面还有 $b$ 个，目前总个数为 $c$ 个，上一个最后放到的位置事 $d$，当前的位置在 $e$，初始状态就是前 L 个和，前面有 $L-1$ 个，总个数为 L，上一个放在正无穷，当前位置 L，特别的，$L \to R$ 这部分我们用一条转移链穿起来，大概就是只有初始状态才能往后添加元素，一旦做了其他转移就不能再添加元素了，具体实现可以看代码，然后剩下的转移就是移动当前位置，不能超过上一个和边界，确定最后一个位置，指针移动到上一个元素，重新开始移动，这里要求移动指针后至少移动一步防止重复，就可以了，特别的，我把非法状态设置成了 inf，如果答案取到 inf 之上就输出 -1 即可。

[Submission(5)](https://loj.ac/s/1435765). 

### CF#713C. Sonya and Problem Wihtout a Legend

[cf#713c](https://www.luogu.com.cn/problem/CF713C). 

题目大意：

给一个 $n$ 个正整数的数组，一次操作中，可以把任意一个元素加一减一，问使得原序列递增的最小操作次数。

$n \le 3000, a_i \le 10^9$。

时间限制：5s。

空间限制：250M。

bonus：$n \le 10^5$。

---

严格递增我们一般令 $a_i - i \to a_i$ 从而将限制转变为严格不降，这个 trick 在 [数字序列](https://www.luogu.com.cn/problem/P4331) 和 [数字序列](https://www.luogu.com.cn/problem/P2501) 中有所应用。

那么设 $f(i, j)$ 表示考虑前 $i$ 个数不降，第 $i$ 个数变成 $j$ 的最小代价，由于 $j$ 取值很少其实就是 $n$ 所以可以容易的优化到 $n^2$ 可以通过原题。

写出柿子观察：

$$
f(i, j) = \min_{k\le j} f(i - 1, k) + |a_i - j|
$$

设 $g(i, j) = \min_{k\le j}f(i, k)$，柿子就比较简单了，可以写成 $f(i, j) = g(i - 1, j) + |a_i - j|$。

这个方程 ... 有没有想到 [[#^ea4bb3|这道题啊]]？

事实上还是有点差别，那道题事 minkowski 和，这道题是函数叠加，不过差别并不算大。

可以发现这玩意始终是凸函数，另外，由于这题转移只需要维护 $g$，求答案也可以只用 $g$，所以只需要维护 $g$ 就行了。

具体维护应该并不困难，$g$ 形如一些斜率递增的一次函数拼接，且变化量为 1，直到斜率为 0 为止，那么直接维护所有斜率变化点即可，考虑每次加入 $a_i$ 为零点的绝对值函数就好了。

如果我在函数最后一个拐点之后加入，那就加入就行了，否则最后一个点就被弹掉了，然后在我这里前后斜率会改变两次，所以加入两次就行了。

[Submission(0)](https://codeforces.com/contest/713/submission/153005196). 

### Luogu#7221. 蔬菜庆典

[luogu#7221](https://www.luogu.com.cn/problem/P7221). 

题目大意：

给你一棵树，有点权，操作事可以将一个点 $i$ 的权值改成 $v_p + v_c - v_i$，即父亲加某个孩子减去自己，如果没有孩子或者没有父亲则不能操作，问操作之后的最大点权和，如果可以达到无穷输出 `+inf`。

$n \le 2 \times 10^5, -10^7 \le v_i \le 10^7$。

时间限制：1s。

空间限制：128M。

---

观察样例解释的操作过程，发现若一个点有父亲，且有两个不同权值的儿子，那就 `+inf` 了，证明就暴力按照样例解释的方法操作几次就看出来了。

但这不完全对啊，有可能操作操作使得出现了不同的儿子，还是寄了。

于是这需要保证儿子无论如何操作不能改变，同时要保证儿子的儿子不能改变，递归下去就行了。

然而发现如果父亲有能改变的，那就可以一路修改下来，使他有两个不同的儿子(如果他的儿子能修改)，依然寄了，所以再把父亲搞一搞就行了。

于是就是先把根除去，然后递归每个子树，显然子树间答案独立，如果某个子树存在分叉点，我们找到第一个分叉点，按死他的子树，他的儿子必须相同，并且他的儿子操作之后(如果能操作)不能改变，递归做即可，如果有一个儿子可以修改(这个儿子有儿子)，那么父亲链上所有点操作后也不能改变，也就是子树被定死了，父亲是否被定死不好说，如果父亲没被定死，相当于是只有一层叶子，就可以操作刨去叶子的这一条链，这个操作事经典操作，相当于交换差分，直接排序即可，至于没有分叉点的，就是一条链，和上一题一样，直接做即可。

至于链上操作怎么就是经典操作了，可以看 [noip2021](https://www.luogu.com.cn/problem/P7962)，忘了第一次见这个操作事什么题了，总之 noip2021 这题印象很深刻。

写了，锅了，不知道锅在哪里，摸了。

# 4.10

### LOJ#3066. 快递

[loj#3066](https://loj.ac/p/3066). 

题目大意：

给定一棵 $n$ 个节点的树，并给出 $k$ 条路径，路径的重合长度定义为边数，试求出最长相交长度，并给出具体路径编号。

$n, k \le 2 \times 10^5$。

2s，256M。

---

不想写了，感觉和情报中心异曲同工。

总之这类树上路径交就是这样，考虑路径交一定有一个路径过另外一个路径的 lca，考虑 lca 相同或者不同，分别画出来讨论讨论，然后看看枚举哪个点来计算贡献，就好辣！

习题：[情报中心](https://www.luogu.com.cn/problem/P4775).

习题：[Journey](https://www.luogu.com.cn/problem/CF1336F). 

# 4.13

[AGC022F](https://www.luogu.com.cn/problem/AT3951)，观摩题解后觉得只能是看题解做，这题非常的不 practical 罢？

# 4.14

### AGC#020F. Arcs on a Circle

[agc#020f](https://www.luogu.com.cn/problem/AT3860). 

题目大意：

你有一个长度为 $C$ 的圆，你在上面画了 $N$ 个弧。弧 $i$ 有长度 $l_i$。

每一条弧ii随机均匀地放置在圆上：选择圆上的一个随机实点，然后出现一条以该点为中心的长度为 $l_i$ 的弧。弧是独立放置的。例如，它们可以相互交叉或包含。

现在问你圆的每一个实点被至少一个弧覆盖的概率是多少？注意一条弧覆盖了它的两个端点。

$n  \le 6, C \le 50, L_i \lt C$。

5s，500M.

---

~~阴间数据范围，看来是不可做题~~。

比上一个 AGCF 要可做，首先我们不妨排序并将 $L_n$ 放在 $0$ 位置往右覆盖，这样的话问题就变成覆盖链的概率了，可以发现概率是相等的，之所以放最长的，就是为了防止最后那个太长，越过开头的来覆盖一段，从而覆盖整条链，这样的情形是难以考虑的，现在的问题变成给定一条链，前面已经覆盖了一部分，剩下 $n - 1$ 条线段随便放，问覆盖整条链的概率，超出部分不用管。

直接在实数上做是比较困难的，[想到这道题](https://www.luogu.com.cn/problem/P3343)，我们真的需要实数嘛？事实上我们只需要小数部分的大小关系就行了，就可以判断两条线段是否相接了。

具体的，我们设 $i$ 线段的左端点出现位置为 $P_i + F_i$，其中 P 是整数部分，F 是小数部分。

我们暴力枚举排列 $A$，要求满足 $F_{A_1} \lt F_{A_2} \lt \cdots \lt F_{A_{n - 1}}$，相等概率是 0，不考虑。

这时候可能成为线段左/右端点的位置只有：

$$
\begin{align}
0, 0 + F_{A_1}, 0 + F_{A_2}, \ldots \\
1, 1 + F_{A_1}, 1 + F_{A_2}, \ldots \\
\ldots
\end{align}
$$

一共 $cn$ 个端点，并且 $K + F_{A_i}$ 显然只能让 $A_i$ 线段放，于是就可以 dp 了！

设 $f(i, j, k)$ 表示考虑完前 $i$ 个端点是否放线段，此时覆盖的最远端点到了 $j$，此时放的线段集合为 $k$ 的方案数。

转移就考虑 $i$ 端点是否要放线段，由于可能放的线段是唯一的，所以转移也比较容易，第一维可以压掉。

自己画画图会更好理解一些。

[Submission(0)](https://atcoder.jp/contests/agc020/submissions/30965264). 

# 4.15

### CF1646E. Power Board

[CF1646E](https://www.luogu.com.cn/problem/CF1646E). 

解题报告：

先把 `1 1 1 1 1...` 判掉。

然后你考虑 `2 4 8...` 第一次重复至少在 `4 16...` 这里，第二次重复至少在 `8 64...` 这里，我们可以考虑把所有可能重复的行放在一起做，都换成 2 的次幂并考虑指数就变成了 $1 \le i \le cnt, 1 \le j \le m$，其中 $cnt$ 是总行数，问所有不同的 $i \times j$ 个数，不难发现 cnt 很小，直接暴力预处理即可。

[Submission(1)](https://codeforces.com/contest/1646/submission/153685279). 

### USACO22OPEN. Hoof and Brain P

[USACO22OPENPtT2](https://www.luogu.com.cn/problem/P8276). 

解题报告：

> 一种常用的解题套路是把无解什么的先判掉，剩下的问题可能就容易处理了。

首先如果一个节点只能走有限步，那么 A 有必胜策略，这可以通过反图拓扑直接求出这些点。

考虑剩下点构成的图，A 剩下的唯一获胜策略就是把两个信标都卡到一个点，如果 $a$ 只有一条通向 $b$ 的边，显然可以合并起来，这是因为如果我们可以把一个点放到 $a$，另一个点卡住，自然也可以在 $b$ 卡，两个点都走一步就可以了，最后得到的图点要么有两个出度以上，要么有自环，发现若两个信标放的点在压缩图后在同一个节点，那么 A 有必胜策略，否则没有，因为 B 总有两个选择，直到自环 B 就可以永远玩下去了。

具体实现我们不显式的合并节点，而是考虑染色，一开始每个节点颜色都不同，接下来若一个节点的出点颜色只有一种，那么就把所有这种颜色染成出点颜色，用 vec 维护颜色集合即可，对于每个点的出色集合也不难维护，更改的时候暴力修改即可，可以均摊到每条边上，至于染色，本质是个集合合并的东西，启发式合并就可以了，复杂度为 ${\cal O}(n \log n)$。

[Code(0)](https://github.com/Z-char/pastebin/blob/master/Luogu%238276.cpp). 

### USACO22OPEN. Up Down sequence P

[USACO22OPENPtT3](https://www.luogu.com.cn/problem/P8277). 

解题报告：

试图官网查看题解，阅读英文困难症 + 不理解劝退了，洛谷题解更是一脸不可读的样子。

[官网题解](http://usaco.org/current/data/sol_prob3_platinum_open22.html)。

### CF1415F

[CF1415F](https://www.luogu.com.cn/problem/CF1415F). 

解题报告：

考虑最终状态，可能是 $n - 1$ 以下都被收集完了，此时我在 $n$，也可能是分身在 $n$，如果分身在 $n$，一定是我亲手收集的 $n - 1$，否则如果 $n - 1$ 被分身收集且我来得及赶到 $n$ 放分身，显然可以放到第一种情况讨论，所以我可以认为我收集完 $n - 1$ 就不动了，坐等分身收集。

反推状态，于是我们考虑设 `min[i]` 表示 $i$ 时刻以下的都被收集了，我跑到 $i$ 的最小时间，设 `can[i][j]` 表示是否有可能我本人在 $i$，保证 $i$ 以下被收集完，并且把分身放到 $j$。

那么只需要 `min[n] <= tim[n] || can[n - 1][n]` 就说明可行，否则不行。

考虑用刷表法转移，为了方便考虑，我们加入一个 0 位置 0 时刻的点。

剩下的就是一些分类讨论了，代码中已经详细注释了，可以通过查看代码或者查看洛谷题解区第一篇题解来获得详细的讨论方法。

[Submission(3)](https://codeforces.com/contest/1415/submission/153708989). 

