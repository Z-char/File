# 4.2

### Luogu#4219. 大融合

[luogu#4219](https://www.luogu.com.cn/problem/P4219). 

题目大意：

给定 $n$ 个点，你需要维护两种操作：

1. 加边，保证加边后原图仍然是森林。
2. 询问 $(x, y)$ 这条边两边 size 乘积，保证边存在。

$n \le 10^5$。

---

动态连边考虑 lct，由于要维护子树信息，考虑对虚儿子整体维护信息，其实这很类似 ddp。

直接维护 `siz[x], siz2[x]` 分别表示真正的 siz 和虚儿子 siz，剩下的我也不知道怎么讲了，你就对着 lct 的板子改一改，需要切换虚实的时候维护一下就行了。

[Submission(0)](https://loj.ac/s/1430219). 

在调试 rotate 的那个 bug 时(代码中已注明)，我确信看到了 0 有父亲并且 0 的 siz 是 1 过，虽然我不知道他的 siz 是什么时候更新的，但是就算不清空 0 节点也可以通过，不过还是清空更为保险一点(

# 4.3

### Luogu#6240. 好吃的题目

题目大意：

多次询问，区间背包。

$n \le 4 \times 10^4, m \le 2 \times 10^5, h_i, t_i \le 200, w_i \le 10^7$。

~~相信大家都猜到了~~，$n, m$ 分别表示物品个数以及询问个数，$h, w$ 分别表示体积和价值，$t$ 表示每次询问的背包大小。

---

只需要离线分治就行了，感觉这题想到分治就结束了，分治背包，对于每个分治区间，跑前后缀，对于被其分割的询问，直接回答，总复杂度为 ${\cal O}(tn \log n + qt)$，空间复杂度大概可以优化到 ${\cal O}(m + nt)$。

并不明白为什么空间爆掉了。

### SP#1812. LCS2

[sp#1812](https://www.luogu.com.cn/problem/SP1812). 

题目大意：

泻药，多串求最长公共子串。

$n \le 10, |s_i| \le 10^5$。

时间限制：236ms。

空间限制：1.46G。

---

这时空限制略显诡异啊？

考虑使用 sam，我们挑一个最短的串建立 sam，接下来拿所有串在上面跑，如果匹配失败了就跳 fail 指针，并重置当前匹配长度为跳到的点的 `len`，然后对于每个节点记录最大 len，然后注意到一个等价类如果可以被匹配到，则 fail 里的串都可以被匹配到，所以在子树里再取 max，最后对自己的长度取 min，这样就得到了这个串匹配每个节点的最大值，对于所有串的结果取 min，然后取全局 max 就好了。

> 如果不好理解的话可以理解为 sam 其实是一个串所有子串的 ac 自动机。

至于时间复杂度，每次跳 fail 相当于至少除去前面一个字符，考虑 kmp 的想法就是了，所以总复杂度是 $\sum |s_i|$ 的。

[Submission(?)](https://www.luogu.com.cn/record/73067104). 

### CF#710F. String Set Queries

[cf#710f](https://www.luogu.com.cn/problem/CF710F). 

题目大意：

维护一个字符串集合，要求支持三种操作：

1. 集合中加入一字符串。
2. 集合中删除一字符串。
3. 给出一字符串，查询集合里所有字符串在模板串里出现的次数和。

**强制在线**。

$m \le 3 \times 10^5, \sum |s_i| \le 3 \times 10^5$。

时间限制：3s。

空间限制：750M。

---

先考虑静态问题，要求串长复杂度，那就对所有文本串建立 ac 自动机，然后 dfs fail 树求出匹配每个节点的贡献，然后模式串暴力在 ac 自动机上跑，求走到的节点权值和即可。

考虑这个问题，事实上加字符串和删除字符串可以看成一种操作，一种 endpos 贡献 1 一种 endpos 走到之后贡献 -1 而已，所以现在只剩下加入字符串和查询了。

如果这个问题可以离线就好了！因为我们现在的问题其实满足：如果修改都在询问之前我们会做，修改对询问的贡献是独立的。我们可以考虑 cdq 分治，每次把左边的串建立 ac 自动机，右边的询问串跑，每个串只会被加入 $\log$ 次 ac 自动机，每个串只会查询 $\log$ 次，这就做完了！

事实上，满足这样性质的问题并不只能 cdq，我们可以用二进制分组做到在线 cdq 分治。

以本题为例，具体的，我们维护 $\log$ 个 ac 自动机，每次查询我们在 $\log$ 个自动机上分别跑，每次加入一个的时候，我们新建自动机，如果这个自动机和上一个自动机串个数相同，我们就合并两个自动机，也就是把串拿出来，重新暴力插入来建立新的自动机。

事实上，有人用线段树来解释这个过程，我们相当于在 $1$ 这个节点加入一个 ac 自动机，然后在 $2$ 加入，一旦有一个节点满足全部被塞满，也就是加入的自动姬个数和区间长度相同，我们就暴力把左右儿子 pushup 上来，我们上面的过程是类似的，只不过由于我们提前不知道线段树长度，我们可以假定这是一个 $2^k$ 长度的二叉树，反正如果不对了，再在后面继续扩展嘛，虽然有一些空节点但是无伤大雅，可以发现每个串被 pushup 的次数只有 $\log$ 次，每个询问拆成的区间也只有 $\log$ 个(线段树嘛)，所以总复杂度是 ${\cal O}(\sum |s_i| \log n)$。

你也可以理解为当 $i$ 次插入时恰好有 $\rm popcount(i)$ 个自动姬，且每个自动姬的大小(串个数)就对应那一位对应的值，进位相当于合并最后一个自动姬和之前的一个自动姬，就行了。

[Submission(1)](https://codeforces.com/contest/710/submission/152576542). 

### LOJ#2197. 向量集

[loj#2197](https://loj.ac/p/2197). 

题目大意：

要求你维护向量集合，支持如下操作：

1. 加入向量 $(x, y)$。
2. 询问 $L, R$ 个加入的向量和 $(x, y)$ 的点积最大值。

**强制在线**。

$n \le 4 \times 10^5$。

时间限制：2s。

空间限制：256M。

---

注意到 $(x, y) \times (z, w) = xz + yw = k$ 这件事稍作变形就可以得到 $z + \dfrac{y}{x} w = \dfrac{k}{x}$，最大化 $k$ 就是最大/最小化右边的柿子，即左边的柿子，事实上，左边的柿子就是经典线性规划，看成 $y + kx = b$ 形式，问题转化为动态加点，每次询问某个斜率的直线切他们，求最大/最小截距(因为除了一个 $x$，我们不知 x 正负)，强制在线。

这里仅讨论求最大截距，那么只会切到上凸壳，如果是静态的，直接维护线段树，每次查询在线段树所有对应节点上二分即可。

这里是强制在线，使用二进制分组，每次节点完全覆盖满之后 pushup 上来，上一题也可以使用这样的方式来做，不过由于询问永远是全局，所以如果 pushup 上来，就可以删掉儿子节点了，所以这道题的做法其实是更为全面，更加强大的，但是上一题那种做法虽然适用范围小，但是更好写，更节省空间时间，如果是全局可以考虑！

[Submission(0)](https://loj.ac/s/1430950). 

### UOJ#191. unknown

[uoj#191](https://uoj.ac/problem/191). 

题目大意：

上一题，不过需要支持新的操作，即撤销最后一次操作。

---

直接套上一题肯定不对，我卡在一个大凸包边缘反复横跳你就爆炸了，考虑更换一下更新条件，每层的某个区间满了，我们就 pushup 这一层的上一个区间，这样每层最多 2 个没有 pushup 的区间，查询复杂度可以保证，如果想逼迫我们重构 $len$ 长度区间，至少要撤销 $len$ 长度，就均摊掉了！赢了！

# 4.4

### ARC#066F. Contest with Drinks Hard

[[2022-3#ARC066D Contest with Drinks Hard|link]]，这里补了一下实现，以及勘误一点：分治过程应该是 $[mid, R]$ 作为右端点贡献到 $[L, mid]$，也就是两边都包含 mid，原因也不难想，考虑左端点合法的右端点范围到底是什么就行了。

代码中的实现是左端点贡献给右端点，附赠一组拍了很久的 hack 数据，另，代码中出现过的 bug 都在代码中注明了，可以看看是否有类似错误。

```
in: 
10
5 6 10 10 5 1 1 6 5 7
5
10 6
8 10
8 6
6 2
7 7

out: 
1
1
1
0
0
```

[Submission(4)](https://atcoder.jp/contests/arc066/submissions/30719248). 

### Luogu#5992. Rozstaw szyn

[luogu#5992](https://www.luogu.com.cn/problem/P5992). 

题目大意：

给你一棵 $n$ 点 $m$ 叶子的树，每个叶子节点有一个权值 $r_i$。

你需要给剩下 $n - m$ 个点分别指定一个权值，使得树上相邻两个点的差的绝对值，求和最小。

$2 \le n \le 5 \times 10^5, m \le n, r_i \le 5 \times 10^5$。

时间限制：1s。

空间限制：125M。

---

设 $f_u(x)$ 表示 $u$ 节点取 $x$ 时子树里的最小代价，儿子的转移形如 $f_v(y) + |x - y| \to f_u(x)$，这实质上相当于 $|x|$ 函数和 $f_v(y)$ 函数做 minkowski sum，然后你对所有儿子求和，由于叶子是凸的，minkowski 之后凸函数仍然是凸的，求和仍然是凸的(对应点相加)，事实上，这个函数就形如一个凸包的样子，于是是可以这么做的(指儿子可以直接 minkowski 因为是凸函数)，然后我们可以直接维护函数，转移就minkowski sum 然后分段函数求和，然而事实上我们只需要维护中间 $k = 0$ 的部分就好了，这是因为转移的时候我们只用到了其与 $|x|$ 的 minkowski sum，你考虑几何意义凸包合并，由于 $|x|$ 无限延伸，所以 minkowski 之后剩下的只会是一个 -1 0 1 斜率的三段函数，而最后求答案显然只需要取中间 0 斜率的部分，于是我们只需要维护中间 0 斜率的高度以及左右端点位置就行了，也就是 **无论转移还是求答案都和边上没关系**。

至于如何求这个，你观察一下就行了，左右端点你发现把儿子的左右端点全部拿出来排序，中间两个对应的线段就是了，因为相当于初始斜率为 $cnt_{son}$，往右扫描，每次增加一个端点斜率 -= 1，所以就不难发现了，用 `nth_element` 可以使总复杂度降为线性，当然你如果使用 `sort` 也无所谓，至于怎么求高度，你都知道不变的区间了，随便选一个端点代入嘛。

[Submission(1)](https://hydro.ac/d/bzoj/record/624cdda1bc977535e24ccd59). 

# 4.6

### Gym#103447L. Karshilov's Matching Problem

[gym#103447l](https://codeforces.com/gym/103447/problem/L). 

题目大意：

给你 $n$ 个模式串，每个串有权值，给你一个文本串，你需要支持下列操作 $m$ 次：

1. 将文本串后缀修改成同一个字符。
2. 对文本串前缀查询 $\sum_{i=1}^n cnt_i \times w_i$，其中 $cnt_i$ 表示前缀中 $i$ 模式串出现次数。

字符集为单个阿拉伯数字，答案取模。

$n \le 10^5, |t_i| \le 10^5, w_i \lt 998244353, |S| \le 3 \times 10^5, m \le 3 \times 10^5, \sum |t_i| \le 10^5$。

时间限制：2s。

空间限制：512M。

---

多少事有点像 [s2oj#266](https://www.sjzezoj.com/problem/266) 的，所以自然可以想到 ac 自动姬上倍增。

显然我们是不能倍增 $S$ 串的，复杂度太高了，但是这题相比那道题的特性就是只会后缀修改，而且 **只有一个字符**，这不是区间推平吗，只有区间推平自然可以想到维护连续段的贡献了(因为区间推平均摊下来对连续段整体的影响是线性级别的)，由于这道题是后缀，那么维护一个单调栈就行了(事实上如果不是后缀就不能这么做了，虽然影响连续段是线性的，但是没法快速维护答案)，考虑一开始我们对于单调栈每个连续段开头的答案都求出来了，并且求出来每个连续段开头会跳到哪里，**注意到字符集只有 10**，可以对 ac 自动姬预处理对每个字符的倍增结果，那么求答案的时候，贰分到连续段开头，倍增过去就好了，修改是容易的，修改位置很少直接求就好了，洒洒水辣！

蚌埠住了，调弱智错误花了半天，然后忘了修改为了调试修改的循环上界又调了半天。

[Submission(1)](https://codeforces.com/gym/103447/submission/152809723) 可能需要 master 以上才能看。

[Code(1)](https://gitee.com/Z_char/pastebin/blob/master/Gym%23103447L.cpp)，我蚌了，开源都要绑定了吗？

[Code(1)](https://github.com/Z-char/pastebin/blob/master/Gym%23103447L.cpp)，github 万岁！可能需要多上几次或者科学一点。

### CF#1616G. Just Add an Edge

[cf#1616g](https://www.luogu.com.cn/problem/CF1616G). 

"你懂了吗？"

“我觉得我懂了”。

于是我不打算详细写了，摸了。

### Gym#103081J. Daisy's Mazes

[gym#103081j](https://codeforces.com/gym/103081/problem/J). 

题目大意：

给你一张 $R$ 个点的图，有 $D$ 条有向边，每条边有颜色，颜色有 $C$ 种，你现在要从 $0$ 走到 $R - 1$，具体的，你的行走方式如下：

1. 如果你的手牌中牌堆顶部为 $s$ 颜色，并且当前所在点有 $s$ 颜色的出边，那你可以任选一个 $s$ 颜色边走，并丢弃顶部手牌。
2. 如果并不匹配或者你没有手牌，你可以任选一个出边，并将这个颜色转化为一张手牌，放入牌堆顶部。

~~可以写成三国杀题面~~。

问你初始最少携带多少手牌，才可以走到目的地。

$2 \le R \le 50, 2 \le D \le 100, 2 \le C \le 20$。

时间限制：3s。

空间限制：256M。

---

主要问题就在于初始牌和走到结尾可能剩下的末尾牌，他的走法并非无迹可寻，事实上可以看出是括号匹配(而且是贪心性质的)，但是初始牌和末尾牌的存在让他的匹配变得十分奇妙，可能你想走的匹配，走到一半被拉走了，可能一些匹配剩到最后没有使用。

官方题解给出了一种非常妙的处理方法，考虑在 0 前面加入 $n - 1$ 个点，每个点向下一个点连所有颜色的边，**这些点间不贪心匹配**，然后让终点连所有颜色的自环，这样从 $-i$ 走到 $n - 1$ 的纯括号匹配路径，就可以对应从牌堆拿出 $i$ 张牌走过去的路径，由于我们是从 `-1` 开始枚举(要求牌堆最小嘛)，所以不会有问题，如果有括号内部匹配了，一定之前就被匹配了，直接做就行了，设 $f(x, y, c)$ 表示提前放个括号 $c$，能否从 $x$ 走到 $y$，且括号匹配，转移就考虑括号匹配外面套括号，以及两段括号拼接就行了，求答案就找一个不存在的颜色来搞即可(这里记颜色是因为括号能否匹配是和上一个括号息息相关的)。

[Submission(3)](https://codeforces.com/gym/103081/submission/152835109). 

[Code(3)](https://github.com/Z-char/pastebin/blob/master/Gym%23103081J.cpp). 

### Gym#103409H. Popcount Words

[gym#103409h](https://codeforces.com/gym/103409/problem/H). 

题目大意：

令 $s_i$ 表示 $\rm popcount(i) \bmod 2$，定义 $w(l, r) = s_ls_{l+1}\ldots s_{r}$。

给出 $S = w(l_1, r_1) + w(l_2, r_2) + \ldots + w(l_n, r_n)$。

接下来有 $q$ 次询问，每次询问给出一个 01 串 $p_i$，询问你 $p_i$ 在 $S$ 中出现多少次。

$n, q \le 10^5, 1 \le l_i \le r_i \le 10^9, \sum |p_i| \le 5 \times 10^5$。

时间限制：1s。

空间限制：512M。

---

首先尝试找找规律，设 $s_i$ 为 $0 \to 2^i - 1$ 对应的 01 串，可以发现 $s_i = s_{i - 1} + \neg s_{i - 1}$，结论不难证明，考虑只是多个首位即可。

那么考虑求出 $p$ 的 ac 自动姬，接下来我们把 $n$ 个串依次在上面跑，具体的，一个串如果用线段树方法，可以拆成若干上面那样的 $s_i$，唯一的区别是 0/1 开头，所以对 ac 自动姬预处理 $f(i, j, 0/1)$ 表示 $i$ 节点，跑 0/1 开头的 $s_j$ 会跑到那里，这样就跑完了，每次跑的时候对这个点打一个标记，即 `tag[i][j][0/1]`，表示这个点跑 $s_{j, 0/1}$ 操作多少次，然后把 tag 下放，就会得到每个点跑 0/1 多少次，这就得到了原串跑 ac 自动姬的结果，然后 fail 树求一下子树和就行了，洒洒水辣！

~~该讲的都讲了，我就不实现了，贺一份~~。

[Code(he)](https://github.com/Z-char/pastebin/blob/master/Gym%23103409H.cpp). 

### AGC#034F. RNG and XOR

[agc#034f](https://www.luogu.com.cn/problem/AT4996). 

题目大意：

给定 $n$ 和长度为 $2^n$ 的数组 $A$(0-index，用于求 $p$ 数组)。

有一个初始为 0 的变量 $x$，每次操作有 $p_i$ 的概率将 $x$ 变成 $x~{\rm xor}~i$，对于所有 $i \in [0, 2^n)$，求出 $x$ 第一次变成 $i$ 的期望步数。

$n \le 18, 1 \le A \le 1000$。

时间限制：3s。

空间限制：1000M。

---

自然的，设 $f_i$ 表示 $i$ 变成 0 的期望步数，有：

$$
f_i = 1 + \sum_{j=0}^{2^n - 1} f_{j~{\rm xor} i} \times p_j
$$

考虑 GF，定义 $\times$ 为 xor 卷积，就有：

$$
F + c = 1 + F \times P
$$

其中 $c$ 是常数修正项(很多 GF 列等式的时候都需要注意这一点吧)，因为 $f_0$ 的转移显然不对。

