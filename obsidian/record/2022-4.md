# 4.2

### Luogu#4219. 大融合

[luogu#4219](https://www.luogu.com.cn/problem/P4219). 

题目大意：

给定 $n$ 个点，你需要维护两种操作：

1. 加边，保证加边后原图仍然是森林。
2. 询问 $(x, y)$ 这条边两边 size 乘积，保证边存在。

$n \le 10^5$。

---

动态连边考虑 lct，由于要维护子树信息，考虑对虚儿子整体维护信息，其实这很类似 ddp。

直接维护 `siz[x], siz2[x]` 分别表示真正的 siz 和虚儿子 siz，剩下的我也不知道怎么讲了，你就对着 lct 的板子改一改，需要切换虚实的时候维护一下就行了。

[Submission(0)](https://loj.ac/s/1430219). 

在调试 rotate 的那个 bug 时(代码中已注明)，我确信看到了 0 有父亲并且 0 的 siz 是 1 过，虽然我不知道他的 siz 是什么时候更新的，但是就算不清空 0 节点也可以通过，不过还是清空更为保险一点(

# 4.3

### Luogu#6240. 好吃的题目

题目大意：

多次询问，区间背包。

$n \le 4 \times 10^4, m \le 2 \times 10^5, h_i, t_i \le 200, w_i \le 10^7$。

~~相信大家都猜到了~~，$n, m$ 分别表示物品个数以及询问个数，$h, w$ 分别表示体积和价值，$t$ 表示每次询问的背包大小。

---

只需要离线分治就行了，感觉这题想到分治就结束了，分治背包，对于每个分治区间，跑前后缀，对于被其分割的询问，直接回答，总复杂度为 ${\cal O}(tn \log n + qt)$，空间复杂度大概可以优化到 ${\cal O}(m + nt)$。

并不明白为什么空间爆掉了。

### SP#1812. LCS2

[sp#1812](https://www.luogu.com.cn/problem/SP1812). 

题目大意：

泻药，多串求最长公共子串。

$n \le 10, |s_i| \le 10^5$。

时间限制：236ms。

空间限制：1.46G。

---

这时空限制略显诡异啊？

考虑使用 sam，我们挑一个最短的串建立 sam，接下来拿所有串在上面跑，如果匹配失败了就跳 fail 指针，并重置当前匹配长度为跳到的点的 `len`，然后对于每个节点记录最大 len，然后注意到一个等价类如果可以被匹配到，则 fail 里的串都可以被匹配到，所以在子树里再取 max，最后对自己的长度取 min，这样就得到了这个串匹配每个节点的最大值，对于所有串的结果取 min，然后取全局 max 就好了。

> 如果不好理解的话可以理解为 sam 其实是一个串所有子串的 ac 自动机。

至于时间复杂度，每次跳 fail 相当于至少除去前面一个字符，考虑 kmp 的想法就是了，所以总复杂度是 $\sum |s_i|$ 的。

[Submission(?)](https://www.luogu.com.cn/record/73067104). 

### CF#710F. String Set Queries

[cf#710f](https://www.luogu.com.cn/problem/CF710F). 

题目大意：

维护一个字符串集合，要求支持三种操作：

1. 集合中加入一字符串。
2. 集合中删除一字符串。
3. 给出一字符串，查询集合里所有字符串在模板串里出现的次数和。

**强制在线**。

$m \le 3 \times 10^5, \sum |s_i| \le 3 \times 10^5$。

时间限制：3s。

空间限制：750M。

---

先考虑静态问题，要求串长复杂度，那就对所有文本串建立 ac 自动机，然后 dfs fail 树求出匹配每个节点的贡献，然后模式串暴力在 ac 自动机上跑，求走到的节点权值和即可。

考虑这个问题，事实上加字符串和删除字符串可以看成一种操作，一种 endpos 贡献 1 一种 endpos 走到之后贡献 -1 而已，所以现在只剩下加入字符串和查询了。

如果这个问题可以离线就好了！因为我们现在的问题其实满足：如果修改都在询问之前我们会做，修改对询问的贡献是独立的。我们可以考虑 cdq 分治，每次把左边的串建立 ac 自动机，右边的询问串跑，每个串只会被加入 $\log$ 次 ac 自动机，每个串只会查询 $\log$ 次，这就做完了！

事实上，满足这样性质的问题并不只能 cdq，我们可以用二进制分组做到在线 cdq 分治。

以本题为例，具体的，我们维护 $\log$ 个 ac 自动机，每次查询我们在 $\log$ 个自动机上分别跑，每次加入一个的时候，我们新建自动机，如果这个自动机和上一个自动机串个数相同，我们就合并两个自动机，也就是把串拿出来，重新暴力插入来建立新的自动机。

事实上，有人用线段树来解释这个过程，我们相当于在 $1$ 这个节点加入一个 ac 自动机，然后在 $2$ 加入，一旦有一个节点满足全部被塞满，也就是加入的自动姬个数和区间长度相同，我们就暴力把左右儿子 pushup 上来，我们上面的过程是类似的，只不过由于我们提前不知道线段树长度，我们可以假定这是一个 $2^k$ 长度的二叉树，反正如果不对了，再在后面继续扩展嘛，虽然有一些空节点但是无伤大雅，可以发现每个串被 pushup 的次数只有 $\log$ 次，每个询问拆成的区间也只有 $\log$ 个(线段树嘛)，所以总复杂度是 ${\cal O}(\sum |s_i| \log n)$。

你也可以理解为当 $i$ 次插入时恰好有 $\rm popcount(i)$ 个自动姬，且每个自动姬的大小(串个数)就对应那一位对应的值，进位相当于合并最后一个自动姬和之前的一个自动姬，就行了。

[Submission(1)](https://codeforces.com/contest/710/submission/152576542). 

### LOJ#2197. 向量集

[loj#2197](https://loj.ac/p/2197). 

题目大意：

要求你维护向量集合，支持如下操作：

1. 加入向量 $(x, y)$。
2. 询问 $L, R$ 个加入的向量和 $(x, y)$ 的点积最大值。

**强制在线**。

$n \le 4 \times 10^5$。

时间限制：2s。

空间限制：256M。

---

注意到 $(x, y) \times (z, w) = xz + yw = k$ 这件事稍作变形就可以得到 $z + \dfrac{y}{x} w = \dfrac{k}{x}$，最大化 $k$ 就是最大/最小化右边的柿子，即左边的柿子，事实上，左边的柿子就是经典线性规划，看成 $y + kx = b$ 形式，问题转化为动态加点，每次询问某个斜率的直线切他们，求最大/最小截距(因为除了一个 $x$，我们不知 x 正负)，强制在线。

这里仅讨论求最大截距，那么只会切到上凸壳，如果是静态的，直接维护线段树，每次查询在线段树所有对应节点上二分即可。

这里是强制在线，使用二进制分组，每次节点完全覆盖满之后 pushup 上来，上一题也可以使用这样的方式来做，不过由于询问永远是全局，所以如果 pushup 上来，就可以删掉儿子节点了，所以这道题的做法其实是更为全面，更加强大的，但是上一题那种做法虽然适用范围小，但是更好写，更节省空间时间，如果是全局可以考虑！

[Submission(0)](https://loj.ac/s/1430950). 

### UOJ#191. unknown

[uoj#191](https://uoj.ac/problem/191). 

题目大意：

上一题，不过需要支持新的操作，即撤销最后一次操作。

---

直接套上一题肯定不对，我卡在一个大凸包边缘反复横跳你就爆炸了，考虑更换一下更新条件，每层的某个区间满了，我们就 pushup 这一层的上一个区间，这样每层最多 2 个没有 pushup 的区间，查询复杂度可以保证，如果想逼迫我们重构 $len$ 长度区间，至少要撤销 $len$ 长度，就均摊掉了！赢了！

# 4.4

### ARC#066F. Contest with Drinks Hard

[[2022-3#ARC066D Contest with Drinks Hard|link]]，这里补了一下实现，以及勘误一点：分治过程应该是 $[mid, R]$ 作为右端点贡献到 $[L, mid]$，也就是两边都包含 mid，原因也不难想，考虑左端点合法的右端点范围到底是什么就行了。

代码中的实现是左端点贡献给右端点，附赠一组拍了很久的 hack 数据，另，代码中出现过的 bug 都在代码中注明了，可以看看是否有类似错误。

```
in: 
10
5 6 10 10 5 1 1 6 5 7
5
10 6
8 10
8 6
6 2
7 7

out: 
1
1
1
0
0
```

[Submission(4)](https://atcoder.jp/contests/arc066/submissions/30719248). 

### Luogu#5992. Rozstaw szyn

[luogu#5992](https://www.luogu.com.cn/problem/P5992). 

题目大意：

给你一棵 $n$ 点 $m$ 叶子的树，每个叶子节点有一个权值 $r_i$。

你需要给剩下 $n - m$ 个点分别指定一个权值，使得树上相邻两个点的差的绝对值，求和最小。

$2 \le n \le 5 \times 10^5, m \le n, r_i \le 5 \times 10^5$。

时间限制：1s。

空间限制：125M。

---

设 $f_u(x)$ 表示 $u$ 节点取 $x$ 时子树里的最小代价，儿子的转移形如 $f_v(y) + |x - y| \to f_u(x)$，这实质上相当于 $|x|$ 函数和 $f_v(y)$ 函数做 minkowski sum，然后你对所有儿子求和，由于叶子是凸的，minkowski 之后凸函数仍然是凸的，求和仍然是凸的(对应点相加)，事实上，这个函数就形如一个凸包的样子，于是是可以这么做的(指儿子可以直接 minkowski 因为是凸函数)，然后我们可以直接维护函数，转移就minkowski sum 然后分段函数求和，然而事实上我们只需要维护中间 $k = 0$ 的部分就好了，这是因为转移的时候我们只用到了其与 $|x|$ 的 minkowski sum，你考虑几何意义凸包合并，由于 $|x|$ 无限延伸，所以 minkowski 之后剩下的只会是一个 -1 0 1 斜率的三段函数，而最后求答案显然只需要取中间 0 斜率的部分，于是我们只需要维护中间 0 斜率的高度以及左右端点位置就行了，也就是 **无论转移还是求答案都和边上没关系**。 ^ea4bb3

至于如何求这个，你观察一下就行了，左右端点你发现把儿子的左右端点全部拿出来排序，中间两个对应的线段就是了，因为相当于初始斜率为 $cnt_{son}$，往右扫描，每次增加一个端点斜率 -= 1，所以就不难发现了，用 `nth_element` 可以使总复杂度降为线性，当然你如果使用 `sort` 也无所谓，至于怎么求高度，你都知道不变的区间了，随便选一个端点代入嘛。

[Submission(1)](https://hydro.ac/d/bzoj/record/624cdda1bc977535e24ccd59). 

# 4.6

### Gym#103447L. Karshilov's Matching Problem

[gym#103447l](https://codeforces.com/gym/103447/problem/L). 

题目大意：

给你 $n$ 个模式串，每个串有权值，给你一个文本串，你需要支持下列操作 $m$ 次：

1. 将文本串后缀修改成同一个字符。
2. 对文本串前缀查询 $\sum_{i=1}^n cnt_i \times w_i$，其中 $cnt_i$ 表示前缀中 $i$ 模式串出现次数。

字符集为单个阿拉伯数字，答案取模。

$n \le 10^5, |t_i| \le 10^5, w_i \lt 998244353, |S| \le 3 \times 10^5, m \le 3 \times 10^5, \sum |t_i| \le 10^5$。

时间限制：2s。

空间限制：512M。

---

多少事有点像 [s2oj#266](https://www.sjzezoj.com/problem/266) 的，所以自然可以想到 ac 自动姬上倍增。

显然我们是不能倍增 $S$ 串的，复杂度太高了，但是这题相比那道题的特性就是只会后缀修改，而且 **只有一个字符**，这不是区间推平吗，只有区间推平自然可以想到维护连续段的贡献了(因为区间推平均摊下来对连续段整体的影响是线性级别的)，由于这道题是后缀，那么维护一个单调栈就行了(事实上如果不是后缀就不能这么做了，虽然影响连续段是线性的，但是没法快速维护答案)，考虑一开始我们对于单调栈每个连续段开头的答案都求出来了，并且求出来每个连续段开头会跳到哪里，**注意到字符集只有 10**，可以对 ac 自动姬预处理对每个字符的倍增结果，那么求答案的时候，贰分到连续段开头，倍增过去就好了，修改是容易的，修改位置很少直接求就好了，洒洒水辣！

蚌埠住了，调弱智错误花了半天，然后忘了修改为了调试修改的循环上界又调了半天。

[Submission(1)](https://codeforces.com/gym/103447/submission/152809723) 可能需要 master 以上才能看。

[Code(1)](https://gitee.com/Z_char/pastebin/blob/master/Gym%23103447L.cpp)，我蚌了，开源都要绑定了吗？

[Code(1)](https://github.com/Z-char/pastebin/blob/master/Gym%23103447L.cpp)，github 万岁！可能需要多上几次或者科学一点。

### CF#1616G. Just Add an Edge

[cf#1616g](https://www.luogu.com.cn/problem/CF1616G). 

"你懂了吗？"

“我觉得我懂了”。

于是我不打算详细写了，摸了。

### Gym#103081J. Daisy's Mazes

[gym#103081j](https://codeforces.com/gym/103081/problem/J). 

题目大意：

给你一张 $R$ 个点的图，有 $D$ 条有向边，每条边有颜色，颜色有 $C$ 种，你现在要从 $0$ 走到 $R - 1$，具体的，你的行走方式如下：

1. 如果你的手牌中牌堆顶部为 $s$ 颜色，并且当前所在点有 $s$ 颜色的出边，那你可以任选一个 $s$ 颜色边走，并丢弃顶部手牌。
2. 如果并不匹配或者你没有手牌，你可以任选一个出边，并将这个颜色转化为一张手牌，放入牌堆顶部。

~~可以写成三国杀题面~~。

问你初始最少携带多少手牌，才可以走到目的地。

$2 \le R \le 50, 2 \le D \le 100, 2 \le C \le 20$。

时间限制：3s。

空间限制：256M。

---

主要问题就在于初始牌和走到结尾可能剩下的末尾牌，他的走法并非无迹可寻，事实上可以看出是括号匹配(而且是贪心性质的)，但是初始牌和末尾牌的存在让他的匹配变得十分奇妙，可能你想走的匹配，走到一半被拉走了，可能一些匹配剩到最后没有使用。

官方题解给出了一种非常妙的处理方法，考虑在 0 前面加入 $n - 1$ 个点，每个点向下一个点连所有颜色的边，**这些点间不贪心匹配**，然后让终点连所有颜色的自环，这样从 $-i$ 走到 $n - 1$ 的纯括号匹配路径，就可以对应从牌堆拿出 $i$ 张牌走过去的路径，由于我们是从 `-1` 开始枚举(要求牌堆最小嘛)，所以不会有问题，如果有括号内部匹配了，一定之前就被匹配了，直接做就行了，设 $f(x, y, c)$ 表示提前放个括号 $c$，能否从 $x$ 走到 $y$，且括号匹配，转移就考虑括号匹配外面套括号，以及两段括号拼接就行了，求答案就找一个不存在的颜色来搞即可(这里记颜色是因为括号能否匹配是和上一个括号息息相关的)。

[Submission(3)](https://codeforces.com/gym/103081/submission/152835109). 

[Code(3)](https://github.com/Z-char/pastebin/blob/master/Gym%23103081J.cpp). 

### Gym#103409H. Popcount Words

[gym#103409h](https://codeforces.com/gym/103409/problem/H). 

题目大意：

令 $s_i$ 表示 $\rm popcount(i) \bmod 2$，定义 $w(l, r) = s_ls_{l+1}\ldots s_{r}$。

给出 $S = w(l_1, r_1) + w(l_2, r_2) + \ldots + w(l_n, r_n)$。

接下来有 $q$ 次询问，每次询问给出一个 01 串 $p_i$，询问你 $p_i$ 在 $S$ 中出现多少次。

$n, q \le 10^5, 1 \le l_i \le r_i \le 10^9, \sum |p_i| \le 5 \times 10^5$。

时间限制：1s。

空间限制：512M。

---

首先尝试找找规律，设 $s_i$ 为 $0 \to 2^i - 1$ 对应的 01 串，可以发现 $s_i = s_{i - 1} + \neg s_{i - 1}$，结论不难证明，考虑只是多个首位即可。

那么考虑求出 $p$ 的 ac 自动姬，接下来我们把 $n$ 个串依次在上面跑，具体的，一个串如果用线段树方法，可以拆成若干上面那样的 $s_i$，唯一的区别是 0/1 开头，所以对 ac 自动姬预处理 $f(i, j, 0/1)$ 表示 $i$ 节点，跑 0/1 开头的 $s_j$ 会跑到那里，这样就跑完了，每次跑的时候对这个点打一个标记，即 `tag[i][j][0/1]`，表示这个点跑 $s_{j, 0/1}$ 操作多少次，然后把 tag 下放，就会得到每个点跑 0/1 多少次，这就得到了原串跑 ac 自动姬的结果，然后 fail 树求一下子树和就行了，洒洒水辣！

~~该讲的都讲了，我就不实现了，贺一份~~。

[Code(he)](https://github.com/Z-char/pastebin/blob/master/Gym%23103409H.cpp). 

### AGC#034F. RNG and XOR

[agc#034f](https://www.luogu.com.cn/problem/AT4996). 

题目大意：

给定 $n$ 和长度为 $2^n$ 的数组 $A$(0-index，用于求 $p$ 数组)。

有一个初始为 0 的变量 $x$，每次操作有 $p_i$ 的概率将 $x$ 变成 $x~{\rm xor}~i$，对于所有 $i \in [0, 2^n)$，求出 $x$ 第一次变成 $i$ 的期望步数。

$n \le 18, 1 \le A \le 1000$。

时间限制：3s。

空间限制：1000M。

---

自然的，设 $f_i$ 表示 $i$ 变成 0 的期望步数，有：

$$
f_i = 1 + \sum_{j=0}^{2^n - 1} f_{j~{\rm xor} i} \times p_j
$$

特别的 $f_0 = 0$。

考虑 GF，定义 $\times$ 为 xor 卷积，就有：

$$
F + c = I + F \times P
$$

其中 $c$ 是因为 $f_0$ 不能那么转移而添加的常数修正项。

直接在 xor_FWT 意义下考虑：

$$
\begin{align}
{\rm FWT}(F) + {\rm FWT}(c) = {\rm FWT}(I) + {\rm FWT}(F) \cdot {\rm FWT}(P) \\
\end{align}
$$

注意到 xor_FWT 变换下常数项其实是所有位置系数求和，那么代入 $i = 0$，可以解得 $c = 2^n$。

于是：

$$
{\rm FWT}(F) = \dfrac{\rm FWT({\it c}) - FWT({\it I})}{{\rm FWT}(p) - {\rm FWT}(1)}
$$

直接上一个 fwt 开始求就行了，唯一的问题，当 $i = 0$ 时分母是 0，这可能导致 ifwt 之后常数不为 0，不妨设为 $x$，但是其他位置的计算都是正确的，于是原来那个相当于常数改成 $x$ 做 fwt 的结果，于是 ifwt 之后就把每一项都减掉 $x$ 就可以了。

[Submission(0)](https://atcoder.jp/contests/agc034/submissions/30777215). 

# 4.8

### LOJ#3322. shopping plan

[loj#3322](https://loj.ac/p/3322). 

题目名称来源洛谷。

---

kth 套路就那么些，拿堆胡乱 pop k 次，二分前 k 个，字典序可能还有按位枚举的操作。

这里肯定是拿堆 pop k 次，这类套路的难点在于设置一个后继的指针，以及设置一个简明的状态，一开始的最小值一般比较好找，如果你能设置一个转移，使得度数很小，并且所有状态构成树，并且状态简明转移快速，并且走到一个点权值单调不减，这样总复杂度就最多只有 ${\cal O}(deg \times k \times \text{扩展代价} + k \times \log n)$，并且不重复，并且肯定是按顺序取出来的。

[原来有道题就很充分的体现了这个特点](https://www.sjzezoj.com/problem/1162)。

这道题也是类似的，我们来设置一个简明的状态，具体的，设 $(a, b, c)$ 表示当前和为 $a$，目前考虑到第 $b$ 种类型，这种类型目前取到了第 $c$ 个状态，后继就是当前类型往后走一步，或者走下一个类型，但是走下一个类型和当前状态其实是重复的，感觉可以记录一个 $d$ 表示当前状态是否算数，这样是不重不漏的，相当于是枚举每个类型到底放到哪里，一个一个枚举，但是由于有无用状态我就不知道复杂度对不对了，感觉还是挺对的最多常数乘 2？题解做法事你每次指针向后移动必须强制选一个，但是这样你可能就只能取到 `2 2 2 2 2...` 了，实际可能取 `1 1 1 1...`，所以我们还需要支持一个 `? 2` 变成 `? 1 2` 的操作，为了保证这个操作边权递增，我们需要把所有种类按照第 2 小减去第 1 小排序，就行了。

还剩下一个问题就是如何求某个种类里面的第 $i$ 小权值，其实也类似做就行了，不过由于有 $L \to R$ 这个限制，我的选择是记录四元组，$(a, b, c, d, e)$ 表示当前的和事 $a$，前面还有 $b$ 个，目前总个数为 $c$ 个，上一个最后放到的位置事 $d$，当前的位置在 $e$，初始状态就是前 L 个和，前面有 $L-1$ 个，总个数为 L，上一个放在正无穷，当前位置 L，特别的，$L \to R$ 这部分我们用一条转移链穿起来，大概就是只有初始状态才能往后添加元素，一旦做了其他转移就不能再添加元素了，具体实现可以看代码，然后剩下的转移就是移动当前位置，不能超过上一个和边界，确定最后一个位置，指针移动到上一个元素，重新开始移动，这里要求移动指针后至少移动一步防止重复，就可以了，特别的，我把非法状态设置成了 inf，如果答案取到 inf 之上就输出 -1 即可。

[Submission(5)](https://loj.ac/s/1435765). 

### CF#713C. Sonya and Problem Wihtout a Legend

[cf#713c](https://www.luogu.com.cn/problem/CF713C). 

题目大意：

给一个 $n$ 个正整数的数组，一次操作中，可以把任意一个元素加一减一，问使得原序列递增的最小操作次数。

$n \le 3000, a_i \le 10^9$。

时间限制：5s。

空间限制：250M。

bonus：$n \le 10^5$。

---

严格递增我们一般令 $a_i - i \to a_i$ 从而将限制转变为严格不降，这个 trick 在 [数字序列](https://www.luogu.com.cn/problem/P4331) 和 [数字序列](https://www.luogu.com.cn/problem/P2501) 中有所应用。

那么设 $f(i, j)$ 表示考虑前 $i$ 个数不降，第 $i$ 个数变成 $j$ 的最小代价，由于 $j$ 取值很少其实就是 $n$ 所以可以容易的优化到 $n^2$ 可以通过原题。

写出柿子观察：

$$
f(i, j) = \min_{k\le j} f(i - 1, k) + |a_i - j|
$$

设 $g(i, j) = \min_{k\le j}f(i, k)$，柿子就比较简单了，可以写成 $f(i, j) = g(i - 1, j) + |a_i - j|$。

这个方程 ... 有没有想到 [[#^ea4bb3|这道题啊]]？

事实上还是有点差别，那道题事 minkowski 和，这道题是函数叠加，不过差别并不算大。

可以发现这玩意始终是凸函数，另外，由于这题转移只需要维护 $g$，求答案也可以只用 $g$，所以只需要维护 $g$ 就行了。

具体维护应该并不困难，$g$ 形如一些斜率递增的一次函数拼接，且变化量为 1，直到斜率为 0 为止，那么直接维护所有斜率变化点即可，考虑每次加入 $a_i$ 为零点的绝对值函数就好了。

如果我在函数最后一个拐点之后加入，那就加入就行了，否则最后一个点就被弹掉了，然后在我这里前后斜率会改变两次，所以加入两次就行了。

[Submission(0)](https://codeforces.com/contest/713/submission/153005196). 

### Luogu#7221. 蔬菜庆典

[luogu#7221](https://www.luogu.com.cn/problem/P7221). 

题目大意：

给你一棵树，有点权，操作事可以将一个点 $i$ 的权值改成 $v_p + v_c - v_i$，即父亲加某个孩子减去自己，如果没有孩子或者没有父亲则不能操作，问操作之后的最大点权和，如果可以达到无穷输出 `+inf`。

$n \le 2 \times 10^5, -10^7 \le v_i \le 10^7$。

时间限制：1s。

空间限制：128M。

---

观察样例解释的操作过程，发现若一个点有父亲，且有两个不同权值的儿子，那就 `+inf` 了，证明就暴力按照样例解释的方法操作几次就看出来了。

但这不完全对啊，有可能操作操作使得出现了不同的儿子，还是寄了。

于是这需要保证儿子无论如何操作不能改变，同时要保证儿子的儿子不能改变，递归下去就行了。

然而发现如果父亲有能改变的，那就可以一路修改下来，使他有两个不同的儿子(如果他的儿子能修改)，依然寄了，所以再把父亲搞一搞就行了。

于是就是先把根除去，然后递归每个子树，显然子树间答案独立，如果某个子树存在分叉点，我们找到第一个分叉点，按死他的子树，他的儿子必须相同，并且他的儿子操作之后(如果能操作)不能改变，递归做即可，如果有一个儿子可以修改(这个儿子有儿子)，那么父亲链上所有点操作后也不能改变，也就是子树被定死了，父亲是否被定死不好说，如果父亲没被定死，相当于是只有一层叶子，就可以操作刨去叶子的这一条链，这个操作事经典操作，相当于交换差分，直接排序即可，至于没有分叉点的，就是一条链，和上一题一样，直接做即可。

至于链上操作怎么就是经典操作了，可以看 [noip2021](https://www.luogu.com.cn/problem/P7962)，忘了第一次见这个操作事什么题了，总之 noip2021 这题印象很深刻。

写了，锅了，不知道锅在哪里，摸了。

# 4.10

### LOJ#3066. 快递

[loj#3066](https://loj.ac/p/3066). 

题目大意：

给定一棵 $n$ 个节点的树，并给出 $k$ 条路径，路径的重合长度定义为边数，试求出最长相交长度，并给出具体路径编号。

$n, k \le 2 \times 10^5$。

2s，256M。

---

不想写了，感觉和情报中心异曲同工。

总之这类树上路径交就是这样，考虑路径交一定有一个路径过另外一个路径的 lca，考虑 lca 相同或者不同，分别画出来讨论讨论，然后看看枚举哪个点来计算贡献，就好辣！

习题：[情报中心](https://www.luogu.com.cn/problem/P4775).

习题：[Journey](https://www.luogu.com.cn/problem/CF1336F). 

