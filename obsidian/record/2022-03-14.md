## 工作
[s2_272](https://www.sjzezoj.com/contest/223/problem/272). 

暴力比较好想，贪心的对于每个工作选前 kth 的工人求和并修改即可。

显然可以用平衡树优化，时间复杂度为 ${\cal O}(n \log n)$。

## 大水题
[s2_266](https://www.sjzezoj.com/contest/223/problem/266). 

考虑维护线段树，对 $[l, r]$ 维护 $f(node)$，其表示从 $node$ 出发走完这个区间，会走到哪里以及权值和，那么询问是 $\log |S|$ 的，只需要按顺序找到对应节点，查询权值和并往后走即可。

考虑带修，不妨对每个修改串维护 $double(i, j)$ 表示从串的 $i$ 位置走 $2^j$ 步，对应的 $f$ 函数，倍增总复杂度为 $len \log |S|$，$f$ 函数的更新需要维护 $|T|$ 个点，所以复杂度为 ${\cal O}(len \log |S| |T|)$，问题在于如何更新线段树，线段树的区间可以通过取模等得到对应的位置，然而我们需要将区间长度拆成二进制表示将 $f$ 拼接才行，那么更新线段树复杂度为 ${\cal O}(Q \log |S| |T| \log |S|)$，其中前一个 log 是用于定位区间，后一个 log 是二进制拆分，T 表示合并的复杂度，可能难以通过。

考虑将线段树补成 $2^{k}$ 长度，这样任意区间长度为二的整次幂，就不需要二进制拆分了，直接赋值即可，复杂度为 ${\cal O}(Q \log |S| |T|)$，可以通过本题。

## 套路
[uoj246](https://uoj.ac/problem/246). 

考虑根号分治，对于长度 $\le \sqrt m$ 的区间，可以在 ${\cal O}(n \sqrt m)$ 的时间内全部计算出来，对于长度 $\gt \sqrt m$ 的区间，可以发现差值不超过 $m / len +1$，那么枚举右端点，枚举差值 $\ge x$，逐渐更新左边界的下界，然后更新答案即可，复杂度为 ${\cal O}(n \sqrt m)$。

