$\newcommand{\l}{\left} \newcommand{\r}{\right}$ 

# 3.12

### CF917C
[cf917c](https://www.luogu.com.cn/problem/CF917C). 

注意到 $k$ 非常的小，自然想到状压，设 $f(i, s)$ 表示考虑完前 $i$ 个位置，青蛙的状态为 $s$ 的最小花费，其中 $s$ 是一个 $k$ 位的二进制数。

转移是容易的，使用矩阵快速幂加速即可，对于特殊石头，在那里停下，转为使用暴力 dp 即可。

# 3.14

### S2#272 工作

[s2#272](https://www.sjzezoj.com/contest/223/problem/272). 

暴力比较好想，贪心的对于每个工作选前 kth 的工人求和并修改即可。

显然可以用平衡树优化，时间复杂度为 ${\cal O}(n \log n)$。

### S2#266 大水题
[s2#266](https://www.sjzezoj.com/contest/223/problem/266). 

考虑维护线段树，对 $[l, r]$ 维护 $f(node)$，其表示从 $node$ 出发走完这个区间，会走到哪里以及权值和，那么询问是 $\log |S|$ 的，只需要按顺序找到对应节点，查询权值和并往后走即可。

考虑带修，不妨对每个修改串维护 $double(i, j)$ 表示从串的 $i$ 位置走 $2^j$ 步，对应的 $f$ 函数，倍增总复杂度为 $len \log |S|$，$f$ 函数的更新需要维护 $|T|$ 个点，所以复杂度为 ${\cal O}(len \log |S| |T|)$，问题在于如何更新线段树，线段树的区间可以通过取模等得到对应的位置，然而我们需要将区间长度拆成二进制表示将 $f$ 拼接才行，那么更新线段树复杂度为 ${\cal O}(Q \log |S| |T| \log |S|)$，其中前一个 log 是用于定位区间，后一个 log 是二进制拆分，T 表示合并的复杂度，可能难以通过。

考虑将线段树补成 $2^{k}$ 长度，这样任意区间长度为二的整次幂，就不需要二进制拆分了，直接赋值即可，复杂度为 ${\cal O}(Q \log |S| |T|)$，可以通过本题。

### UOJ#246 套路
[uoj#246](https://uoj.ac/problem/246). 

考虑根号分治，对于长度 $\le \sqrt m$ 的区间，可以在 ${\cal O}(n \sqrt m)$ 的时间内全部计算出来，对于长度 $\gt \sqrt m$ 的区间，可以发现差值不超过 $m / len +1$，那么枚举右端点，枚举差值 $\ge x$，逐渐更新左边界的下界，然后更新答案即可，复杂度为 ${\cal O}(n \sqrt m)$。

# 3.22
### S2#1133 tree
[s2#1133](https://sjzezoj.com/problem/1133). 

题意实在是简洁易懂，~~说明题目已经难到不需要用读题消耗你的精力了~~。

感觉 dp 方法很多样，不过非常容易记重，记漏，记错，也许题解的思路还是有一定程度的借鉴意义的。

考虑枚举直径中点来统计答案，这是因为一只树可能有多只直径，非常容易记重，而计数题常用套路就是 **就算没有特征也给你拆出来特征出来**，比如整数划分强行将 1 分为一类，比如括号序列要求第一段必须是 (expr) 形式，我们人为的，强行的规定一个分界点或者类别划分，这样就可以在分界点处/不同类处来划分，统计，达到不重复的计数的目的。

那么考虑一些直径的特点？不管直径有多少，~~不管风雨有多少，有你就足够~~，**中点是唯一的**，那么要在中点计数。

由于在信息里记录直径相关信息是困难的，考虑枚举直径长度(计数题要善用枚举)，以中点为分界线，就只对深度有限制了，并且之需要求出方案数而非带权和了。

考虑直径为偶数，那么中点为一个点，设 $h(i, j)$ 表示 $i$ 个有标号点构成的树，深度恰好为 $j$ 的方案数，那直接上一个 $h(n, d/2)$，至于只有一个子树的容斥掉就好了，所以还需要一个 $f(i, j)$ 表示 $i$ 标号深度小于等于 $j$ 的方案数。

考虑直径为奇数，把边断掉，两边分别是一个 $h(i, d/2)$ 和 $h(n-i, d / i)$。

为了求 $f(i, j)$，还需要维护一个 $g(i, j)$ 表示 $i$ 点深度不到 $j$ 的森林个数，不难 dp，dp 后暴力统计即可。

复杂度 ${\cal O}(n^3)$。

### Luogu#4067 储能表

[luogu#4067](https://www.luogu.com.cn/problem/P4067). 

先二进制分解 $n, m, k$，直接数位 dp，设 $f(i, 0/1, 0/1, 0/1)$ 表示填到 $i$ 位，是否顶 $n, m, k$ 上界，分数以及方案数，直接转移就可。

巨大多 typo，没有开 ll，但凡看一眼所有的错误输出不至于调半天，数组没清空，**多测一定要单独开一个 clear 函数提醒自己清空**！

[Submission(**11**)](https://www.luogu.com.cn/record/72121883). 

### UOJ#140. 被粉碎的数字

[uoj#140](https://uoj.ac/problem/140). 

看起来就很数位 dp，然而填数的时候 k 导致的前缀巨大修改是难以维护的，信息相对复杂。

注意到因为 $k$ 只有 1000，所以如果从后往前填最多会多出来 3 位，可以考虑从后往前 dp，暴力记录前面的位。

设 $f(i, j, {\rm upd}, {\rm diff})$ 表示已经填到 $i$，与 R 的大小关系为 $j$，前面的位是 upd，目前的数位和差是 diff(没有考虑 upd 三位的 $f(kx) - f(x)$)的方案数，直接做即可。

[Submission(0)](https://uoj.ac/submission/541999). 

### BZOJ#4230. countdown

[bzoj#4230](https://hydro.ac/d/bzoj/p/4230). 

设 $f(i)$ 表示 $i$ 需要的次数，尝试证明其单调不减，即 $f(i - 1) \le f(i)$，数归之，令 $i - 1$ 以下都满足，设 $g(i)$ 表示 $i$ 最大的数位，显然有 $g(i) + 1 \ge g(i + 1)$，即 $g(i) \le g(i - 1) + 1$，即 $i$ 能到达的位置为 $i - g(i)$，不会优于 $i - 1 - g(i - 1) = i - (1+g(i-1)) \le i - g(i)$，所以归纳假设成立。

于是每次减去最大值就是最优的，然暴力做肯定不能过。

考虑一次快速退位，具体的，令 $f(i, j, k)$ 表示前缀 max 为 $i$，后缀形如 $\overbrace{99999999...}^{j \text{个}}k$ 的数字，把后缀减到小于 $0$，最后一位应该变成什么，以及需要多少次操作，也就是从前借位后，会变成 99999... 谁，转移就枚举第一个 $9$ 的变化过程，每次变化之后，后缀仍然形如一串 9 + 个位，于是可以递推，或者理解成把前面减退位一次，会变成 9999啥，需要多少次操作。

状态之所以这么定义是因为借位之后后缀会形如 9999999k 形式，这样定义退位后仍可容易的递推。

预处理复杂度为 $\sigma^3 \log N$，求答案的过程就是考虑除了个位后缀 9 个数，每次让前面退位，一个位置最多退 9 次就变成 9 了，所以总共退 $\sigma \log N$ 次，不过还要求前缀 max 和后缀 9，不过这都是很小的值，进制和长度都是小值，仍然随便过。

[Submission(1)](https://hydro.ac/d/bzoj/record/623c5dc0d48588880961622a). 

# 3.24

### Luogu#4128. set

[luogu#4128](https://www.luogu.com.cn/problem/P4128). 

也就是求对完全图边染色方案数，点置换同构。

这种置换同构问题很容易想到 burnside 引理。

然而我们对于点置换，却是对边染色，考虑一个点的置换下，如何求出染色方案数，使得置换后同构。

首先对于一个点置换，他可以拆成若干轮换，不妨设拆成 $b_1, b_2, \ldots, b_k$ 这 k 个轮换。

考虑两类边，一类边是在某一个轮换里面的边，对于这样的边，由于要求转一次后同构，也就是长度相同的边，他们需要是同一个颜色，可以发现一共有 $b/2$ 个等价类。

另一类边是横跨两个轮换的边，不妨设长度为 $x, y$，考虑对于一条边，其会和多少边同色，也就是你考虑选两个点，同时往后转，什么时候转回来，其实就是 lcm 条，由于总共 $x \times y$ 条，所以可以自由选的等价类只有 $\gcd(x, y)$ 个。

大概是这样：

![image-20220325114220389.png](image-20220325114220389.png)

标号个数就是同色边个数，可以发现一共有 12 个标号，说明 12 条边同色，和上面的结论一致。

于是把两个结论结合起来，说明等价类个数为：

$$
\sum_{i} \l\lfloor \dfrac{b_i}{2} \r\rfloor + \sum_{i \lt j} \gcd(b_i, b_j)
$$

可以发现这个东西只和划分相关，而 53 的划分其实不多，可以搜索，假设我们搜索了一个整数划分，考虑如何求出对应的置换个数，首先对于划分应该选点，这是多重集合的排列，接下来对于每个轮换内部应该扔一个圆排列，然而会算重，考虑如果有相同的 $b$，内部是不应该有序的，除掉 $\prod 1/{c_i!}$ 即可，其中 $c_i$ 表示大小为 $i$ 的轮换个数。

稍加整理就可以得到答案柿子：

$$
\sum \dfrac{1}{\prod b_i \prod c_i!} m^{\sum \l\lfloor\dfrac{b_i}{2} \r\rfloor + \sum_{i \lt j} \gcd(b_i, b_j)}
$$

由于有 $i \lt j$ 的求和 + gcd，所以时间复杂度大约为：

$$
{\cal O}\l(\log n\sum_{p \in {\rm Partition}(n)}{\rm len}^2(p) \r)
$$

[Submission(1)](https://hydro.ac/d/luogu/record/623dcea2f8a852b8e35f9ede). 

tip：

指数取模时请参考 fermat's little theorem 或者 euler theorem，不能直接对 p 取模。

# 3.28

### CF1630E

[cf1630e](https://www.luogu.com.cn/problem/CF1630E). 

题目大意：

给定一序列 $a$，求从 a 的本质不同的排列中随机选择一个，价值的期望。

本质相同定义为旋转同构。

序列的价值定义为若全相等则为 1，否则为 $n - pr$，其中 $pr$ 为相邻相等数对个数，或者是 $pr_2$，即相邻不等数对个数，注意，序列是环形的。

$n \le 10^6$。

---

旋转同构则不难想到 burnside 引理。

我们求出所有本质不同下的价值和，并求出本质不同的排列个数，除一下就是答案。

很显然我们并不关心序列的样子，我们只关心每个数字出现了多少次，不妨设出现了 $c$ 个不同的数字，分别设出现次数为 $cnt_1, cnt_2, \ldots, cnt_c$。

那么考虑计算本质不同排列个数，自然地，枚举每个旋转，考虑等价类个数为 $\gcd(n, k)$，每个的大小为 $d = n/\gcd(n, k$，那么方案数自然是 $\binom{\gcd(n, k)}{cnt_1/d, cnt_2/d, \ldots, cnt_c/d}$。

直接枚举 $k$ 的话复杂度是 ${\cal O}(nc)$ 的，寄了！

然而显然很多 $k$ 是不合法的，以及很多 $\gcd$ 是相同的，显然合法的 $\gcd$ 一定是满足 $\gcd | \gcd(n, cnt_i)$ 的，那么可以先求出后面那个东西，考虑枚举约数去快速计算方案数，也就是我们考虑对每个 $\gcd$ 求出 $f$ 即可，反正只有这些位置有用，而 $1e5$ 的约数个数很少，随便做。

求出这个之后总方案数就是 $\sum_{i=1}^n f_{\gcd(i, n)} / n$。

现在的问题就是求总贡献和了。

还是一样的套路咯，考虑求出每个 $\gcd$ 的 $g$。

直接求 $g$ 比较困难，考虑贡献，具体来说就是枚举两个不同的数，钦定他俩在某个位置相邻，剩下的方案数直接计算，需要注意的是，一次相邻就会在每个复制的位置相邻一次，所以答案是：

$$
g_L = \binom{L - 2}{cnt_1/d, cnt_2/d, \ldots, cnt_x/d - 1, \ldots, cnt_y/d - 1, \ldots, cnt_c/d - 1} \times n
$$

后面的 n 是枚举在 $L$ 的哪里相邻，以及翻倍的位置也要相邻。

发现这个东西其实是：

$$
\dfrac{f_L \times cnt_x \times cnt_y}{L \times (L - 1) \times d^2} \times n
$$

所以其实只需要求出 $\sum_{x \neq y} (cnt_x/d) \times (cnt_y/d)$ 就好了，而这并不难求。

求和得到总贡献和，除一下就得到答案了，懒了，不想自己写了。

[code_not_by_me](https://codeforces.com/contest/1630/submission/146245747). 

放别人的提交记录了。

**关于群论**：

关于群论的做题记录到这里就暂时先告一段落了，其实后面还有 "烷基计数"，"同分异构体计数"，"烷烃计数" 等神仙题目，如果未来有机会，也许会再去学习吧。

