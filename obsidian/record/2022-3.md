$\newcommand{\l}{\left} \newcommand{\r}{\right}$ 

# 3.12

### CF917C
[cf917c](https://www.luogu.com.cn/problem/CF917C). 

注意到 $k$ 非常的小，自然想到状压，设 $f(i, s)$ 表示考虑完前 $i$ 个位置，青蛙的状态为 $s$ 的最小花费，其中 $s$ 是一个 $k$ 位的二进制数。

转移是容易的，使用矩阵快速幂加速即可，对于特殊石头，在那里停下，转为使用暴力 dp 即可。

# 3.14

### S2#272 工作

[s2#272](https://www.sjzezoj.com/contest/223/problem/272). 

暴力比较好想，贪心的对于每个工作选前 kth 的工人求和并修改即可。

显然可以用平衡树优化，时间复杂度为 ${\cal O}(n \log n)$。

### S2#266 大水题
[s2#266](https://www.sjzezoj.com/contest/223/problem/266). 

考虑维护线段树，对 $[l, r]$ 维护 $f(node)$，其表示从 $node$ 出发走完这个区间，会走到哪里以及权值和，那么询问是 $\log |S|$ 的，只需要按顺序找到对应节点，查询权值和并往后走即可。

考虑带修，不妨对每个修改串维护 $double(i, j)$ 表示从串的 $i$ 位置走 $2^j$ 步，对应的 $f$ 函数，倍增总复杂度为 $len \log |S|$，$f$ 函数的更新需要维护 $|T|$ 个点，所以复杂度为 ${\cal O}(len \log |S| |T|)$，问题在于如何更新线段树，线段树的区间可以通过取模等得到对应的位置，然而我们需要将区间长度拆成二进制表示将 $f$ 拼接才行，那么更新线段树复杂度为 ${\cal O}(Q \log |S| |T| \log |S|)$，其中前一个 log 是用于定位区间，后一个 log 是二进制拆分，T 表示合并的复杂度，可能难以通过。

考虑将线段树补成 $2^{k}$ 长度，这样任意区间长度为二的整次幂，就不需要二进制拆分了，直接赋值即可，复杂度为 ${\cal O}(Q \log |S| |T|)$，可以通过本题。

### UOJ#246 套路
[uoj#246](https://uoj.ac/problem/246). 

考虑根号分治，对于长度 $\le \sqrt m$ 的区间，可以在 ${\cal O}(n \sqrt m)$ 的时间内全部计算出来，对于长度 $\gt \sqrt m$ 的区间，可以发现差值不超过 $m / len +1$，那么枚举右端点，枚举差值 $\ge x$，逐渐更新左边界的下界，然后更新答案即可，复杂度为 ${\cal O}(n \sqrt m)$。

# 3.22
### S2#1133 tree
[s2#1133](https://sjzezoj.com/problem/1133). 

题意实在是简洁易懂，~~说明题目已经难到不需要用读题消耗你的精力了~~。

感觉 dp 方法很多样，不过非常容易记重，记漏，记错，也许题解的思路还是有一定程度的借鉴意义的。

考虑枚举直径中点来统计答案，这是因为一只树可能有多只直径，非常容易记重，而计数题常用套路就是 **就算没有特征也给你拆出来特征出来**，比如整数划分强行将 1 分为一类，比如括号序列要求第一段必须是 (expr) 形式，我们人为的，强行的规定一个分界点或者类别划分，这样就可以在分界点处/不同类处来划分，统计，达到不重复的计数的目的。

那么考虑一些直径的特点？不管直径有多少，~~不管风雨有多少，有你就足够~~，**中点是唯一的**，那么要在中点计数。

由于在信息里记录直径相关信息是困难的，考虑枚举直径长度(计数题要善用枚举)，以中点为分界线，就只对深度有限制了，并且之需要求出方案数而非带权和了。

考虑直径为偶数，那么中点为一个点，设 $h(i, j)$ 表示 $i$ 个有标号点构成的树，深度恰好为 $j$ 的方案数，那直接上一个 $h(n, d/2)$，至于只有一个子树的容斥掉就好了，所以还需要一个 $f(i, j)$ 表示 $i$ 标号深度小于等于 $j$ 的方案数。

考虑直径为奇数，把边断掉，两边分别是一个 $h(i, d/2)$ 和 $h(n-i, d / i)$。

为了求 $f(i, j)$，还需要维护一个 $g(i, j)$ 表示 $i$ 点深度不到 $j$ 的森林个数，不难 dp，dp 后暴力统计即可。

复杂度 ${\cal O}(n^3)$。

### Luogu#4067 储能表

[luogu#4067](https://www.luogu.com.cn/problem/P4067). 

先二进制分解 $n, m, k$，直接数位 dp，设 $f(i, 0/1, 0/1, 0/1)$ 表示填到 $i$ 位，是否顶 $n, m, k$ 上界，分数以及方案数，直接转移就可。

巨大多 typo，没有开 ll，但凡看一眼所有的错误输出不至于调半天，数组没清空，**多测一定要单独开一个 clear 函数提醒自己清空**！

[Submission(**11**)](https://www.luogu.com.cn/record/72121883). 

### UOJ#140. 被粉碎的数字

[uoj#140](https://uoj.ac/problem/140). 

看起来就很数位 dp，然而填数的时候 k 导致的前缀巨大修改是难以维护的，信息相对复杂。

注意到因为 $k$ 只有 1000，所以如果从后往前填最多会多出来 3 位，可以考虑从后往前 dp，暴力记录前面的位。

设 $f(i, j, {\rm upd}, {\rm diff})$ 表示已经填到 $i$，与 R 的大小关系为 $j$，前面的位是 upd，目前的数位和差是 diff(没有考虑 upd 三位的 $f(kx) - f(x)$)的方案数，直接做即可。

[Submission(0)](https://uoj.ac/submission/541999). 

### BZOJ#4230. countdown

[bzoj#4230](https://hydro.ac/d/bzoj/p/4230). 

设 $f(i)$ 表示 $i$ 需要的次数，尝试证明其单调不减，即 $f(i - 1) \le f(i)$，数归之，令 $i - 1$ 以下都满足，设 $g(i)$ 表示 $i$ 最大的数位，显然有 $g(i) + 1 \ge g(i + 1)$，即 $g(i) \le g(i - 1) + 1$，即 $i$ 能到达的位置为 $i - g(i)$，不会优于 $i - 1 - g(i - 1) = i - (1+g(i-1)) \le i - g(i)$，所以归纳假设成立。

于是每次减去最大值就是最优的，然暴力做肯定不能过。

考虑一次快速退位，具体的，令 $f(i, j, k)$ 表示前缀 max 为 $i$，后缀形如 $\overbrace{99999999...}^{j \text{个}}k$ 的数字，把后缀减到小于 $0$，最后一位应该变成什么，以及需要多少次操作，也就是从前借位后，会变成 99999... 谁，转移就枚举第一个 $9$ 的变化过程，每次变化之后，后缀仍然形如一串 9 + 个位，于是可以递推，或者理解成把前面减退位一次，会变成 9999啥，需要多少次操作。

状态之所以这么定义是因为借位之后后缀会形如 9999999k 形式，这样定义退位后仍可容易的递推。

预处理复杂度为 $\sigma^3 \log N$，求答案的过程就是考虑除了个位后缀 9 个数，每次让前面退位，一个位置最多退 9 次就变成 9 了，所以总共退 $\sigma \log N$ 次，不过还要求前缀 max 和后缀 9，不过这都是很小的值，进制和长度都是小值，仍然随便过。

[Submission(1)](https://hydro.ac/d/bzoj/record/623c5dc0d48588880961622a). 

# 3.24

### Luogu#4128. set

[luogu#4128](https://www.luogu.com.cn/problem/P4128). 

也就是求对完全图边染色方案数，点置换同构。

这种置换同构问题很容易想到 burnside 引理。

然而我们对于点置换，却是对边染色，考虑一个点的置换下，如何求出染色方案数，使得置换后同构。

首先对于一个点置换，他可以拆成若干轮换，不妨设拆成 $b_1, b_2, \ldots, b_k$ 这 k 个轮换。

考虑两类边，一类边是在某一个轮换里面的边，对于这样的边，由于要求转一次后同构，也就是长度相同的边，他们需要是同一个颜色，可以发现一共有 $b/2$ 个等价类。

另一类边是横跨两个轮换的边，不妨设长度为 $x, y$，考虑对于一条边，其会和多少边同色，也就是你考虑选两个点，同时往后转，什么时候转回来，其实就是 lcm 条，由于总共 $x \times y$ 条，所以可以自由选的等价类只有 $\gcd(x, y)$ 个。

大概是这样：

![image-20220325114220389.png](image-20220325114220389.png)

标号个数就是同色边个数，可以发现一共有 12 个标号，说明 12 条边同色，和上面的结论一致。

于是把两个结论结合起来，说明等价类个数为：

$$
\sum_{i} \l\lfloor \dfrac{b_i}{2} \r\rfloor + \sum_{i \lt j} \gcd(b_i, b_j)
$$

可以发现这个东西只和划分相关，而 53 的划分其实不多，可以搜索，假设我们搜索了一个整数划分，考虑如何求出对应的置换个数，首先对于划分应该选点，这是多重集合的排列，接下来对于每个轮换内部应该扔一个圆排列，然而会算重，考虑如果有相同的 $b$，内部是不应该有序的，除掉 $\prod 1/{c_i!}$ 即可，其中 $c_i$ 表示大小为 $i$ 的轮换个数。

稍加整理就可以得到答案柿子：

$$
\sum \dfrac{1}{\prod b_i \prod c_i!} m^{\sum \l\lfloor\dfrac{b_i}{2} \r\rfloor + \sum_{i \lt j} \gcd(b_i, b_j)}
$$

由于有 $i \lt j$ 的求和 + gcd，所以时间复杂度大约为：

$$
{\cal O}\l(\log n\sum_{p \in {\rm Partition}(n)}{\rm len}^2(p) \r)
$$

[Submission(1)](https://hydro.ac/d/luogu/record/623dcea2f8a852b8e35f9ede). 

tip：

指数取模时请参考 fermat's little theorem 或者 euler theorem，不能直接对 p 取模。

# 3.28

### CF1630E

[cf1630e](https://www.luogu.com.cn/problem/CF1630E). 

题目大意：

给定一序列 $a$，求从 a 的本质不同的排列中随机选择一个，价值的期望。

本质相同定义为旋转同构。

序列的价值定义为若全相等则为 1，否则为 $n - pr$，其中 $pr$ 为相邻相等数对个数，或者是 $pr_2$，即相邻不等数对个数，注意，序列是环形的。

$n \le 10^6$。

---

旋转同构则不难想到 burnside 引理。

我们求出所有本质不同下的价值和，并求出本质不同的排列个数，除一下就是答案。

很显然我们并不关心序列的样子，我们只关心每个数字出现了多少次，不妨设出现了 $c$ 个不同的数字，分别设出现次数为 $cnt_1, cnt_2, \ldots, cnt_c$。

那么考虑计算本质不同排列个数，自然地，枚举每个旋转，考虑等价类个数为 $\gcd(n, k)$，每个的大小为 $d = n/\gcd(n, k$，那么方案数自然是 $\binom{\gcd(n, k)}{cnt_1/d, cnt_2/d, \ldots, cnt_c/d}$。

直接枚举 $k$ 的话复杂度是 ${\cal O}(nc)$ 的，寄了！

然而显然很多 $k$ 是不合法的，以及很多 $\gcd$ 是相同的，显然合法的 $\gcd$ 一定是满足 $\gcd | \gcd(n, cnt_i)$ 的，那么可以先求出后面那个东西，考虑枚举约数去快速计算方案数，也就是我们考虑对每个 $\gcd$ 求出 $f$ 即可，反正只有这些位置有用，而 $1e5$ 的约数个数很少，随便做。

求出这个之后总方案数就是 $\sum_{i=1}^n f_{\gcd(i, n)} / n$。

现在的问题就是求总贡献和了。

还是一样的套路咯，考虑求出每个 $\gcd$ 的 $g$。

直接求 $g$ 比较困难，考虑贡献，具体来说就是枚举两个不同的数，钦定他俩在某个位置相邻，剩下的方案数直接计算，需要注意的是，一次相邻就会在每个复制的位置相邻一次，所以答案是：

$$
g_L = \binom{L - 2}{cnt_1/d, cnt_2/d, \ldots, cnt_x/d - 1, \ldots, cnt_y/d - 1, \ldots, cnt_c/d - 1} \times n
$$

后面的 n 是枚举在 $L$ 的哪里相邻，以及翻倍的位置也要相邻。

发现这个东西其实是：

$$
\dfrac{f_L \times cnt_x \times cnt_y}{L \times (L - 1) \times d^2} \times n
$$

所以其实只需要求出 $\sum_{x \neq y} (cnt_x/d) \times (cnt_y/d)$ 就好了，而这并不难求。

求和得到总贡献和，除一下就得到答案了，懒了，不想自己写了。

[code_not_by_me](https://codeforces.com/contest/1630/submission/146245747). 

放别人的提交记录了。

**关于群论**：

关于群论的做题记录到这里就暂时先告一段落了，其实后面还有 "烷基计数"，"同分异构体计数"，"烷烃计数" 等神仙题目，如果未来有机会，也许会再去学习吧。

# 3.29

### Luogu#4366

[luogu#4366](https://www.luogu.com.cn/problem/P4366). 

题目大意：

给你一张 $n$ 点 $m$ 边的有向图，边有边权，并有一组完全图的边，但是边权有特点，即 $(i, j, (i {~ \rm xor ~} j) \times c)$。

$n \le 10^5, m \le 2 \times 10^5$。

---

不难想到那些边肯定好多没有用的 ...

直接猜结论就好了，每次肯定是只改变一位，交上去，过了。

其实也不难证明，你就考虑异或为 1 的位置表示不同，那就每次把这个位置加上去，贡献和异或值一样，就做完了。

### Luogu#5281. Minimax 搜索

[luogu#5281](https://www.luogu.com.cn/problem/P5281). 

怎么说？turtle？不好评价呢。

省略一些看题解到情绪崩溃的骂人内容。

恰等于 k 是一个很强的限制，考虑转化为小于等于 k。

注意到各叶子互不相同，与题面相同的设 $W$ 为最后根的权值。

可以发现，对于每个叶子，其权值覆盖的位置是一条向上的链，只不过 $W$ 覆盖到了根，发现根改变的充要条件就是这条链上有一个位置被修改。

考虑计算多少个集合在 k 次以内不能改变这条链，用总的集合减去就可以得到小于等于 k 的解(这里的 k 次指 max = k)。

不妨设我们需要求的是 $f(1, k)$，即 $k$ 次操作不能改变 1 的集合数目，可以发现每个子树的叶子集合互不影响，相互独立，所以可以求每个子树的方案数，乘起来就是答案了，对于 `value = W` 的儿子，其子树里的叶子集合就是 $f(son, k)$，如果我当前是奇数，那么其他儿子要不超过 $W$，否则其他儿子不小于 $W$，我们递归的去做即可，对于 `value = W` 继续调用这个递归，小于大于的分别取新的递归，如果要求不能超过 $W$，考虑其深度再讨论即可。

对应如下的代码过程：

```cpp
int getMax(int pos, int fa, int delta, int goal) { // value of root smaller than or equal with goal
	if (a[pos].size() == 1) {
		int ans = 0;
		if (value[pos] <= goal) ans++;
		if (value[pos] + delta <= goal) ans++; 
		return ans;
	}
	if (depth[pos] & 1) {
		int ans = 1;
		for (auto x : a[pos])
			if (x != fa) ans = 1ll * ans * getMax(x, pos, delta, goal) % P;
		return ans;
	} else {
		int ans = 1;
		for (auto x : a[pos])
			if (x != fa) ans = 1ll * ans * (two[size[x]] - getMax(x, pos, delta, goal) + P) % P;
		return (two[size[pos]] - ans + P) % P;
	}
}
int getMin(int pos, int fa, int delta, int goal) { // value of root larger than or equal with goal
	if (a[pos].size() == 1) {
		int ans = 0;
		if (value[pos] >= goal) ans++;
		if (value[pos] - delta >= goal) ans++; 
		return ans;
	}
	if (depth[pos] & 1) {
		int ans = 1;
		for (auto x : a[pos])
			if (x != fa) ans = 1ll * ans * (two[size[x]] - getMin(x, pos, delta, goal) + P) % P;
		return (two[size[pos]] - ans + P) % P;
	} else {
		int ans = 1;
		for (auto x : a[pos])
			if (x != fa) ans = 1ll * ans * getMin(x, pos, delta, goal) % P;
		return ans;
	}
}
int getans(int pos, int fa, int delta) {
	int ans = 1;
	for (auto x : a[pos])
		if (x != fa) {
			if (value[x] == value[pos]) ans = 1ll * ans * getans(x, pos, delta) % P; // ok, getans(x, fa, del) means x 子树内 del 次操作不能改变 rt[x] 的方案数
			else if (depth[pos] & 1) ans = 1ll * ans * getMax(x, pos, delta, value[pos]) % P;
			else ans = 1ll * ans * getMin(x, pos, delta, value[pos]) % P;
		}
	return ans;
}
```

对于每个 k 暴力做这个过程，我们就得到一个 ${\cal O}((R-L)\times N)$ 的算法(上述代码摘自 cz_xuyixuan)。

这就可以直接用 ddp 做了，对每个点维护应该如何转移到父亲即可。

具体来说，按照套路，先求 ldp，然后暴力中一共有 7 种转移，可以暴力写 7 个矩阵，现在要求 $f(1)$，直接连乘积就好了，然后稍微有点问题就是和切树游戏一样，这玩意是可能乘出来 0 的，你修改的时候就要把这个除掉，所以还需要维护一个 Z 整数类，哈哈，做完了，只胡不写，摸了，也不知道为啥自己居然看了这么久，得快一天了吧？感觉上可能是畏难情绪，看的时候投入程度不高，并且不想写，所以才反复拖，但最后还是咕掉了不是么 ...

# 3.30

### LOJ#3157. robot

[loj#3157](https://loj.ac/p/3157). 

题目大意：

给你 $n$ 个变量，第 $i$ 个变量有取值范围 $[L_i, R_i]$，现在有两个机器人，一个机器人会一直往左走直到碰到一个比起点高的柱子，一个机器人会一直往右走直到碰到一个不低于起点的柱子，他们两个都不会越过边界，问有多少种设置变量的方法，可以使得任意设置起点，两个机器人移动过得柱子数量差的绝对值小于等于 2.

答案对 $10^9 +7$ 取模。

$1\le n \le 300, 1\le L_i, R_i \le 10^9$。

---

计数题，看起来很不组合数学，事 dp，看数据范围，事区间 dp！

设 $f(l, r)$ 表示只考虑 $[l, r]$，有多少种设置满足题目要求。

考虑从序列中最右边的最大值开始走，显然左边会一口气走到头，右边也一样，并且这个位置会卡住两边使得两边互不影响，所以不妨考虑枚举最右边的最大值，这就可以划分状态了，不过需要注意的是，我们这样划分之后，子任务的上界就有了限定，不能随心所欲的取了，所以考虑增加一维，设 $f(l, r, k)$ 表示这个区间，最大值为 k 的方案数。

那么有转移：

$$
f(l, r, k) = \sum_{|(r-i)-(i-l)| \le 2} \l(\sum_{x\le k}f(l, i - 1, x)\r) \l(\sum_{y\lt k} f(i + 1, r, y)\r) 
$$

答案是 $\sum_k f(l, r, k)$。

由于划分点很少，当 $n \le 300$ 时，记忆化搜索访问到的区间不过 2518 个，所以可以跑到 ${\cal O}(?V)$ 的复杂度(前缀和优化一下转移就是常数了)，可以通过 50pts。

观察到值域非常的巨大，直接 dp 无论如何也不可做吧，看起来就像是那种 dp 出来一部分，剩下的拉插的题目。

事实上确实如此，我们考虑所有 $L, R$ 相同的这一档部分分，一个 $f(l, l, k)$ 显然是关于 $k^0$ 的多项式(如果值域里都可以取)，其前缀和则是 $k^1$ 多项式，那么你观察转移的柿子，就可以归纳得出长度为 $r - l + 1$ 的区间的确是关于 $k$ 的 $r - l$ 次多项式，前缀和则是 $r - l +1$ 次多项式，于是我们把 dp 数组写成 $f_{l, r}(k)$ 形式，在这一档部分分，我们要求的是 $\sum f_{1, n}(m)$，只需要 ${\cal O}(2518n)$ 求出前 $n$ 个值，直接 lagrange 插值即可(时间复杂度为 ${\cal O}(n)$，因为下标连续所以可以线性插值)，为了方便，我们直接将 $f$ 变为前缀和数组，这样转移的时候方便，最后插值的时候也方便一些(因为要插值前缀和数组)。

但是对于并非所有 $L, R$ 相同的测试点，你发现就不适用了，因为并非值域里都可以取，可能对 $k$ 有所限制，但是没关系，我们可以把所有 $l_i, r_i$ 放到数轴上，这会形成 ${\cal O}(n)$ 段，显然对于这一段来说，我们是可以做的，因为这一段对于所有 $l, r$ 是多项式，直接暴力做然后插值就行了，一共做段数次，所以复杂度为 ${\cal O}(2518 n^2)$，插值是同复杂度的，可以通过本题。

**sol2**：

我们还有另外一种做法，对于 $k$ 定义域为 $1 \to max$，$f_{l, r}(k)$ 并不是单纯地一个多项式函数了，然而也不过就是一个分段函数罢了。

从 $f_{l, l}()$ 以及空集开始，直接维护分段函数，观察转移：

$$
f(l, r, k) = \sum_{|(r-i)-(i-l)| \le 2} \l(\sum_{x\le k}f(l, i - 1, x)\r) \l(\sum_{y\lt k} f(i + 1, r, y)\r) 
$$

暴力维护分段函数，每段函数考虑写成下降幂多项式，即有限微积分形式，这样我们做一次微积分就相当于求前缀和(否则你没法前缀和呀，必须要有限微积分才能整数函数前缀和)，而且复杂度只和项数相关，那么递归求出两边的分段函数，求前缀和(积分)，右边的多项式后移一位(其实就是加一个原多项式)，至于乘法，暴力跑下降幂的 $n^2$ 乘法就可以了。

需要注意的几个细节：

1. 维护分段函数的时候，第 $i$ 个多项式，它取 $b[i]$ 处的点值才恰好是分段函数 $b[i]$ 的点值，也就是我们并不把这个多项式平移到从 0 开始，如果你平移了，那么点积(是多项式的卷积)就很困难了，因为你可能两个起点不同的多项式乘起来，你就需要平移处理，事实上，这和数学上的分段函数是统一的，也许只有我才会傻傻的认为平移了(
2. 分段函数积分(前缀和)的时候，记得减去错误的贡献(自己前面不在定义域的部分也积分了！)，加上上一段的正确贡献。
3. 由于有限微积分定义的差分为 $f(x + 1) - f(x)$，如果按照这个定义写下降幂多项式的乘法积分等，需要注意 $i$ 位置的点值表示的是 $[0, i)$ 左闭右开区间的和。

这个东西的复杂度应该是每个合法段对应的长度平方和(暴力乘法复杂度)，即 ${\cal O}(\sum {\rm len}^2)$。

