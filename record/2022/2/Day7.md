$\def\l{\left} \def\r{\right} \def\lr#1#2#3{\l#1 #3 \r#2}$ 
## CF1553H

[cf1553h](https://codeforces.com/problemset/problem/1553/H). 

先建立 trie 树，显然可以扫一遍求出 $x = 0$ 的答案，考虑对于一个子树求出所有的答案，注意到高于这里的位是没用的，故只需要计算一部分即可，考虑合并答案，单从一个子树里的答案容易求，直接继承即可，需要注意的是这一位放 $0/1$ 均可，继承需要继承两个，至于两边各选一个的，暴力枚举 $x$ 的值，从两个子树里查询小的最大值和大的最小值的差即可，根的深度为 $k$，显然 $T(k) = 2^{k-1} \times 2 + k \times 2^k + 2T\lr(){k - 1}$，第一部分是左右儿子继承的复杂度，第二部分是暴力枚举并求最大最小异或值的复杂度，第三部分是递归复杂度。

不难发现，深度为 $d$ 层的总贡献是 $d 2^k$ 级别，求和得到复杂度为 $k^2 2^k$ 级别，可以通过，如果最大值和最小值也通过继承的想法往上做的话，可以做到 ${\cal O}(k 2^k)$。

[submission(0)](https://codeforces.com/contest/1553/submission/145518872). 

## CF1523F

[cf1523f](https://codeforces.com/problemset/problem/1523/F). 

$n$ 很小自然想到状压，一个自然的想法是 $f(s, i, j)$ 表示点亮传送门为 $s$，此时在 $i$ 点(传送门和任务都算)，此时解决 $j$ 个任务的最小时间，复杂度为 ${\cal O}(2^n (n + m)^3)$，稳定超时。

注意到，如果在一个传送门，就在所有的传送门了，并不需要记录在哪个点，此时需要记录的是解决了多少任务，以及点亮的传送门集合，值里存储最小时间，如果确定在某一个任务，那么最小时间是确定的，需要记录传送门，当前是哪个任务，值里储存最多解决任务个数。

于是维护两个数组 $f(s, i), g(s, i)$，第一个表示传送门第二个表示任务，不论如何转移 $s$ 是单调不降的，可以按 $s$ 升序枚举，$f/g \to f$ 的转移不在同层，可以直接刷表，至于 $f \to g$ 的转移是同层的，且应该在 $g \to g$ 之前进行，然后就是 $g \to g$，这样的转移 $j$ 递增，那么 $j$ 应该从小到大枚举，这样才能产生任务走到任务的效果。

复杂度为 ${\cal O}(2^n (n + m)^2)$。

注意事项：转移顺序，先更新本层的 $g$，最后再用 $g$ 更新 $f$。

[submission(1)](https://codeforces.com/contest/1523/submission/145542872). 

## AGC17F

[agc17f](https://atcoder.jp/contests/agc017/tasks/agc017_f). 

等价于填 $m$ 个长度为 $n - 1$ 的二进制数，对于某些二进制数的某些位有限制，另外，要求 $i$ 的任意一个前缀 `popcount` 都要不小于 $i - 1$ 同前缀的 `popcount`。

一个自然的想法是设 $f(i, s)$ 表示考虑完前 $i$ 个数，上一个数是 $s$ 的方案数，直接暴力枚举这一个数并 `check` 即可，这样的复杂度是 ${\cal O}(4^n n)$，不能通过。

可以考虑将填数变成一位一位填，这样的话，维护当前矩形轮廓线上的数字为 $2^n$，转移只需要考虑这一位即可，但是由于前缀 `popcount` 的限制，所以还要记录上一列的前缀 $1$ 个数，枚举填格子的复杂度是 $nm$ 的，状态数是 $2^n n$，仍然没法通过本题。

考虑优化状态，我们不希望记录前缀 `popcount`，但是为了合法，我们可以考虑取巧做法，具体的，每次放一个 $1$ 的时候，就把左边的第一个 $1$ 干掉，不难发现这样的状态是等效的，后续合法的状态原来情况下也合法，那么如果一个位置左边是 $1$，这里不能放 $0$，状态就变成了 $2^n$，这样的话复杂度就是 ${\cal O}(2^n nm)$，辅以 4s 时限，可以通过。

[submission(2)](https://atcoder.jp/contests/agc017/submissions/29156481). 

