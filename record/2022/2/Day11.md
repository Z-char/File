## 51nod1248

[51nod1248](https://vjudge.net/problem/51Nod-1248). 

特征方程解得 $x = 3 \pm 2\sqrt 2$，注意到 $x_1 \times x_2 = 1$，那么令 $r = x_1$，则 $f(n) = (r^n + r^{-n})/2$。

容易发现 `Diff` 的结果是谁减谁都无所谓，不会影响答案，所以设 `D` 表示去除绝对值的 `Diff`。

把 $r$ 和 $r^{-1}$ 拆开考虑，现在的问题就是求 $\sum_{s} k^{D(s)}$，其中 $k$ 是一个定值。

简单 dp 即可。

代码咕了。

## LOJ2736

[loj2736](https://loj.ac/p/2736). 

考虑分块，走过一个块时，答案会变成 $\max(A, \max S)$。

考虑对于每个块维护一个大根堆，若 $A \lt s.top()$，那么你弹出堆顶，并把 $A$ 打到这个块的标记上，具体的，每个块维护一个标记队列，其中维护所有穿过的 $A$(并且有过修改)，这是整块的修改，边角块你考虑求出现在的这个块，然后暴力修改并重构。

所以如果我们能快速求出边角块部分，那么就可以 ${\cal O}(q \sqrt n \log n)$ 查询答案。

这也不难，我们上面维护了有修改的所有 $A$，把他们插入一个小根堆，然后从前往后扫描原块，如果当前这个位置小于最小值，那他一定被修改成最小值了，那么把这个位置修改掉，并把原值塞入小根堆里，跑一遍就得到了修改后的块，暴力跑边角然后重构块即可。

复杂度 ${\cal O}(q \sqrt n \log n)$。

代码咕了。

## AGC21E

[agc21e](https://atcoder.jp/contests/agc021/tasks/agc021_e). 

考虑一只变色龙什么情况下是红色的，要么喂得红球超过蓝球，要么相等，但是最后一次喂蓝球。

由于方案不同只和喂的颜色序列有关，可以考虑枚举红球的喂的次数，考虑用一些技巧快速计算此时的方案数。

若 $r \lt b$ 说明无解，根据鸽笼原理，必然有一个变色龙蓝球超过红球。

若 $r \ge b + n$ 说明一定有解，存在一种方案使得每个变色龙吃的红球都比篮球多，方案数就是简单组合数。

否则 $b \le r \lt b + n$，这是问题的难点。

由于 $r$ 的范围，若序列合法，一定存在一种方案，使得变色龙要么吃的相等，要么恰好多一。

不难发现，会有 $r - b$ 个变色龙多吃一个，其他变色龙吃的一样多。

考虑 $r = b$ 的情况，由于最后一个一定是 `B`，我们可以直接删除这个球，合法序列数等于 $(r, b - 1)$ 的方案数，如此，就至少有一个变色龙多吃一个了。

接下来考虑令所有相等的变色龙吃的都是 `RB`，否则一定存在一个 `RB` 的子序列，我们考虑抽出这个子序列，把剩下的全都塞给那只贪吃的变色龙，一样是合法的，即若合法，一定存在一种方案，使得所有相等的吃的都是 `RB` 序列。

那么一个序列是合法的，当且仅当可以抽出 $n - (r - b)$ 个 `RB` 子序列。

那么对于序列的任何一个前缀来说，浪费的蓝色球不能超过 $b - (n - (r - b)) = r - n$ 个，也就是 $cntb - cntr \le r - n$。

剩下的就是经典问题了，以 $cntr$ 为 $x$ 坐标轴，$cntb$ 为 $y$ 轴建立平面直角坐标系，等价于从 $(0, 0)$ 走到 $(r, b)$，其中能走的区域是 $y \le x + (r - n)$，也就是不能走到 $y = x + (r - n) + 1$ 这条直线上以及其上方，这是 `Catalan` 数类似物，类似的求方案数即可。

代码咕了。

## CF704E

[cf704e](https://codeforces.com/problemset/problem/704/E). 

先把每条路径拆解到重链和轻链上，考虑处理出所有链上的答案，取最小值即为答案。

现在的问题变成一条数轴，上面会出现一些点，给定这些点的出现时间，出现位置，行进方向，行进速度，消失时间，问你最小什么时候，出现两点相交。

考虑画出 $s-t$ 图(其中 $s$ 表示到链顶的距离)，每个点在其上对应一条线段，现在的问题就是求出 $t$ 最小的交点。

如果到两条线段如果中间夹着别的线段就永远不可能贡献答案。

那么考虑扫描线，从左往右扫描，碰到一个线段的左端点就加入线段，并查询它上下的线段分别是谁，并求出交点并更新答案，删除的时候，同理，合并上下线段，贡献他们的答案。

需要注意的一点是，如果当前扫描的位置已经大于等于求出的交点时刻，就不要继续往后扫了，否则一旦有交点，线段的相对位置可能改变，而这在 `set` 之中是未定义的(这里使用 `set` 维护线段)。

复杂度为 ${\cal O}(m \log m \log n)$。

代码咕了。

## Luogu7897

[luogu7897](https://www.luogu.com.cn/problem/P7897). 

近现代 cf 有一道 [重题](https://codeforces.com/contest/1606/problem/F)。

对于每个询问 ${\cal O}(n)$ 的处理是显然的，设 $f(x)$ 表示 $x$ 子树内选择的最大权值，显然有转移 $f(u) = a_u + x + \sum_{v\in son(u)} \max(f(v), 0)$。

注意到随着 $x$ 单调增加，$f(u)$ 也是单调增加的。

那么考虑把 $x$ 离线排序，$x$ 逐渐变大的过程中，若存在 $f(u) \ge 0$ 了，那么让他向父亲连边。

注意到对于这个森林，转移为 $f(u) = a_u + x + \sum_{v\in son(u)} f(v)$。

不难发现这就是子树和 + $siz \times x$。

