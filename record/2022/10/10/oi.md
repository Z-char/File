## CR825(div2)

#### A.

傻逼题。

#### B.

显然意味着 $b_i, b_{i + 1}$ 都是 $a_i$ 的倍数，取 $b_i = {\rm lcm}(a_i, a_{i - 1})$，显然这是至少的条件，如果取更大的数字不会更优。

#### C1.

题意：给你一个数列，问有多少个子串是好的，定义好为 $a_i \ge i$，$n \le 2 \times 10^5, a_i \le n$。

一开始让 $a_i = a_i - i$，枚举左端点 st 表维护区间最值直接二分即可，时间复杂度为 ${\cal O}(n \log n)$。

---

做 c2 时注意到单调性，直接双指针即可，无需 st 表。

#### C2.

题意：同 c1，但是 $q$ 询问单点修改，$q \le 2 \times 10^5$。

一个想法可能是按照上一题的做法求出前缀答案和后缀答案？

现在的问题只剩下如何快速统计过一个点的答案了。

注意到随着左端点往左移动右端点显然单调不增，然并卵，时间复杂度仍然为 ${\cal O}(nq)$，无法通过。

如果考虑对于每个左端点预处理出原来可能的最右端点呢？

那么显然包含这个的区间才会被统计贡献，容易二分，单独考虑修改的限制就可以做了，还有一个小问题，有一些不包含的可能在修改后可以包含这个节点了，不难考虑到只会修改一个节点所以我们再维护一个支持一次非法的最右端点即可，求答案两次二分分别考虑即可，时间复杂度 ${\cal O}((n+q) \log n)$。
