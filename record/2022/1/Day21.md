模拟赛

## A. words

直接上 `hash`，枚举匹配长度，复杂度是 $2e8$ 的。

---

自然溢出遗憾离场。

## B. strings

$k$ 非常大，拿堆维护不可取。

二分也没有可以用来当作基准的模板 —— 除非你暴力枚举模板串，但这复杂度是不对的。

不过对于字典序，还有一种做法是逐位贪心。

现在的问题是，对于一个位置，还能走 $L - t$ 步，有多少种走法可以经过终止节点，如果之前已经经过终止节点另说。

一些细节：

1. 需要注意是否前缀已经是合法串。
2. 需要先 dfs 下放 tag。

不懂为什么出锅了，很烦。

笑死，ac 自动机都写不对了。

## C. coins

1. 银币和金币不会一起用，否则不如留着银币。
2. 只看使用的金币，不存在两次使用等量金币，否则可以替换，保留更多金币。
3. 银币只会一个一个使用。

对于 $x, y \le 10$，可以爆搜。

对于 $x = 0$，只需要整数划分即可，$f(i, j) = f(i - 1, j) + f(i - 1, j - i)$。

---

改题

## A. words

广义 sam，fail 树上 dfs，如果当前点是某个串的结尾，显然到根的链上所有点对应的串都是我的后缀，考虑对于插入过程中记录每个串的每个前缀插到了那个点，实现就在每个点开一个 `vector` 记录都有哪些串插入过程中插入到他了即可，可以注意到，这个节点的最长串一定对应插入的这个前缀，于是对于那些串可以更新他们的路径上最长前缀，于是在路径上找这些串的最长前缀即可，因为路径上的点都是我的后缀，故这就是最长的匹配后缀前缀，回溯的时候撤销影响，维护更新了哪些串的最长前缀，以及原来是什么，然后赋值回去即可。

## C. coins

难题。

设 $f(i, j)$ 表示 **一次使用金币至少为 $i$ 枚**，总共有 $j$ 枚金币时能表示出的数的数量。

若 $x = 0$，答案为 $f(1, y)$。

否则，记 $x$ 的二进制表示最高位为 $2^l$，令 $k = l + 2$。

考虑对所有数按照模 $2^k$ 的余数 $r$ 分类，这是因为银币可能的管辖范围处于 $[0, 2^{l + 2})$。

若 $r \in [0, x]$，我们不需要花费金币，如果我们是用金币进位到 $k$ 位，那大可不必，因为 $l + 1$ 位至少需要放金币，剩下的还至少需要一个金币，至少需要 $l + 2$ 金币才达到 $r + 2^k$，显然可以直接放在 $k$，不会变劣，所以每一个 $r \in [0, x]$ 提供 $f(k, y)$ 的贡献。

若 $r \in (x, x + 2]$，可以用一个金币解决问题，$x + 1$ 少放一个银币即可。

若 $r \in (x + 2, x + 4]$，此时你需要 $+3/4$，由于金币只能是整次幂，所以至少需要 $2$ 个金币解决问题。

和一开始同理，我们只会花费至少的金币去解决问题，否则一定不优。

不难发现这样的划分只有 $\log$ 段。

考虑最后的 $r \in (x + 2^{l}, x + 2^{l + 1}]$，这时候至少需要 $l + 1$ 个金币，然后会继续变成 $r \in (x + 2^{l + 1}, x+2^{l + 1} + 2]$，这是因为我们的金币不会放在 $l + 2$ 的位置，会被取模掉，继续分段即可，仍然只有 $\log$ 段。

总结：

1. 发现银币的贡献是很小的，$l + 2$ 以上只能是金币贡献，所以可以考虑 $[0, 2^{l + 2})$ 区间最少放多少个金币就可以达成目的，剩下的用于高位。
2. 发现 $[0, 2^{l + 2})$ 可以分段，每段最少金币是确定的，而且最少金币一定是最优策略。

## CF200A

[cf200a](https://www.luogu.com.cn/problem/CF200A). 

暴力 + 优化，复杂度不明。

另外一种优化是考虑拿并查集维护每一行连续段，查询的时候大力枚举 $x$ 坐标，然后用并查集查询 $y$ 最接近的，由于只有 $k$ 个询问，所以 $\sqrt k$ 级别内一定有解，当 $d \gt nowans$ 时退出即可，不可能再更新了，复杂度就是 ${\cal O}(k \sqrt k)$ 的。

## CF204D

[cf204d](https://www.luogu.com.cn/problem/CF204D). 

这种两部分的最好拆开计算。

为了不计重，设 $f(i)$ 表示以 $i$ 结尾是一个 $B$ 串，且 **之前没有 $B$ 串的** 前 $i$ 个字符方案数，$g(i)$ 表示在 $i$ 之后存在一个 $W$ 串的方案数。

答案显然是 $\sum f(i) \times g(i + 1)$。

