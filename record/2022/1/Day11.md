## gym102331J

[gym102331j](https://codeforces.com/gym/102331/problem/J). 

~~jiry~~？九条可怜！

树是二分图，这是二分图最大权匹配，不难转化费用流模型，故答案关于 $k$ 是一个凸函数，单点求值自然可以 wqs 二分，如果求 $k \in [1, n)$，类似上一道题的，可以想到闵和。

设 $f(i, j, 0/1)$ 表示 $i$ 的子树里，选了 $j$ 个，此时 $i$ 是否被覆盖的最大权。

合并两颗子树时就有：
$$
f(i, k_1, x) + f(y, k_2, y) \to f(i, k_1 + k_2 (+1), ?)
$$
我们成功将转移优化到了 ${\cal O}(siz_1 + siz_2)$，现在可以 ${\cal O}(n^2)$ 解决本题，但是过不去，考虑一些好的合并方式。

然而闵和合并不是 ${\cal O}(\max(siz_1, siz_2))$ 而是 ${\cal O}(siz_1 + siz_2)$，于是启发式合并是行不通的。

现在我们其实是知道每个节点单独成联通块的答案，合并两个联通块需要 ${\cal O}(siz_1 + siz_2)$ 的复杂度，希望找到一种合并的顺序/方法，使得复杂度优秀起来。

考虑特殊的一些情况，如果是一个菊花，那么可以分治，具体的，设函数 `solv(l, r)` 会返回一个 `pair`，他代表考虑 $[l, r]$ 这些叶子处理完之后的答案 $(f_0, f_1)$，其中 $f_0$ 表示 $x$ 并没有匹配，也就是一条边没有选，$f_1$ 表示 $x$ 匹配了，这就可以分治做了，发现每一层的总复杂度不会超过 `siz` 和，这是因为闵和的复杂度是 $siz$ 和，每次取中点最多 $\log$ 层，复杂度就是 ${\cal O}(n \log n)$。

如果是一条链，我们仍然可以分治，类似上一道题的(昨天的最后一题)，设 `solv(l, r)` 返回一个四元组，`g[0][0], g[0][1], g[1][0], g[1][1]`，分别表示左右端点是否已经匹配的那个函数，每层的复杂度还是不会超过 ${\cal O}(n)$，总复杂度仍然是 ${\cal O}(n \log n)$。

菊花告诉我们，儿子是可以合并的，链告诉我们，一条链是可以快速计算答案的。

于是考虑链分治，先对树做重链剖分，每个点预处理和轻儿子合并的结果，记作 `f[x][0], f[x][1]`，每次需要用一条链的时候，分治求这条链的答案，其实很像 ddp。

> 复杂度分析：
>
> 考虑轻儿子合并的复杂度，单点合并轻儿子，设轻儿子子树大小总和为 $siz_l$，那么总复杂度就是 ${\cal O}(\sum siz_l \log siz_l) = {\cal O}(\log n \sum siz_l) = {\cal O}(n \log^2 n)$，第一步是闵和分治复杂度分析，第二步是简单放缩，第三步是经典结论，轻儿子子树大小和不过 $n \log n$，证明就是 dsu on tree 的证明，因为一个点往上跳的轻链最多 $\log n$ 级别(跳一次 siz 翻倍)，所以轻子树总大小只有 $n \log n$。
>
> 考虑重链的复杂度，由于重链只会在链首贡献一次，而一层的复杂度为轻儿子之和，所以复杂度应该是 ${\cal O}(\log \sum siz_l \log ?) = {\cal O}(n \log^3 n)$ $\ldots$ 吗？
>
> 考虑更毛估估一点的方法，一条重链对应的所有轻子树大小和不会超过 $n$，我们可以直接按照一条重链的时间复杂度为 ${\cal O}(n \log n)$ 来计算，由于会被贡献 $\log $ 次，所以复杂度是 ${\cal O}(n \log ^2 n)$ 的。
>
> 所以可以简单得出结论，轻儿子由于子树和性质，复杂度为合并复杂度乘 $\log$，重儿子由于跳轻链限制，所以复杂度为合并复杂度乘 $\log$。
>
> 所以只会多一个 $\log$。

这样做复杂度是 ${\cal O}(n \log ^2 n)$ 的，可以通过本题。

~~但是代码写挂了 WA on 27 拿头调啊，gym 调题属于是弱智了~~。

先放上去了，后续再改。

**upd2022-1-12**：放弃了，借了学长的号看错误信息，$n = 2e5$，错误在 $30000$ words，我看是没救了，拍也拍不出来。

**upd2022-1-12**：好奶，直接拍出来了，然后模拟前夕打算整体看一看，突然就发现一个小错，修了之后没当回事，**结果过了对拍数据**，震撼，交上去就过了，虽然不懂为啥，但是过了就是好事。

