## CF39C

[cf39c](https://www.luogu.com.cn/problem/CF39C). 

由于圆心共线，所以可以转化为选一些区间，使得区间只有包含以及相离关系，最大化区间个数。

肯定要先排序的，可以按左端点升序，右端点降序来排序。

考虑 dp 的想法，设 $f(i)$ 表示最后一个选择线段为 $i$ 的最大个数。

然而并不可转移，一来是前面的右端点可能交我的左端点，二来是我中间那些线段怎么选也是需要 dp 的。

为了解决这两个限制，考虑设 $g(l, r, k)$ 表示选 $[l, r]$ 区间的线段，右端点小于等于 $k$ 时，最多可以选多少个。

这样就可以转移了，前面的答案是 $g(1, i - 1, l_i)$，后面的答案可以说是 $g(i + 1, n, r_i)$。

但是复杂度显然是不对的。

由于注意到答案最终形式类似括号序列，先选出极大区间再递归处理，可以有以下想法：

考虑按照值域来处理，先离散化所有端点，设 $f(l, r)$ 表示完全在 $[l, r]$ 范围内的答案。

如果暴力枚举分界点进行 dp，复杂度是 ${\cal O}(n^3)$ 的。

但是考虑，如果我们让 $f(l, r)$ 继承自 $f(l + 1, r)$，显然这一次的分割只需要考虑 $l$ 为左端点的线段进行的分割即可，之前相当于是 $n$ 长度线段的所有子段长度和，是 ${\cal O}(n^3)$ 的，现在对于一个 $r$，其所有 $l$ 对应枚举总数为 $n$，而 $r$ 也是 $n$ 级别的，所以总复杂度为 ${\cal O}(n^2)$，可以通过本题。

## Luogu4563

[luogu4563](https://www.luogu.com.cn/problem/P4563). 

一开始没看到只能监视 **横坐标不超过他的**，有了这个限制不难发现从右往左推即可。

## CF49E

[cf49e](https://www.luogu.com.cn/problem/CF49E). 

因为原串一个字符一定扩展成连续一段区间，于是有如下思路：

设 $f(i, j)$ 表示 $s_1$ 前 $i$ 字符和 $s_2$ 前 $j$ 字符的 sca(shortest common ancester)，转移暴力枚举哪一段和哪一段匹配。

那么现在需要处理 $g(0/1, l, r, ch)$ 表示 $s_{1/2}$ 中 $[l, r]$ 字符是否可以被 `ch` 字符取代。

考虑 `ch` 字符对应的转移，若存在分割点使得 $g(0/1, l, mid, a) = 1, g(0/1, mid + 1, r, b) = 1$，那么就可以。

## CF55D

[cf55d](https://www.luogu.com.cn/problem/CF55D). 

直接 $2^{10}$ 暴力枚举每个数字是否出现，这样只要和是 $\rm lcm$ 的倍数即可，直接设 $f(x, 0/1, mod)$ 数位 dp 即可。

不过由于 $0 \to 9$ 的 $\rm lcm$ 只有 2520，所以另一种做法是记录 $2520$ 的模数以及此时的 $\rm lcm$。

## CF73D

[cf73d](https://www.luogu.com.cn/problem/CF73D). 

考虑二分答案，猜测将小的逐渐匹配，然后只要 $\sum \min(siz, k) \ge 2(blo - 1)$ 就可以做到。

考虑小的匹配的过程，似乎不需要二分答案，逐渐匹配，动态维护后面的不等关系即可。

## CF85D

[cf85d](https://www.luogu.com.cn/problem/CF85D). 

考虑离线，把所有值拿下来然后离散化，权值线段树维护即可，类似青少年 icpc 那道线段树，维护一个偏移量即可，或者你动态开点，或者你平衡树都可以。

## CF86D

[cf86d](https://www.luogu.com.cn/problem/CF86D). 

这不是直接开莫？

## CF93C

[cf93c](https://www.luogu.com.cn/problem/CF93C). 

显然从二进制的角度看我们七步之内一定可以做到。

直接爆搜 + 迭代加深即可。

## CF103E

[cf103e](https://www.luogu.com.cn/problem/CF103E). 

如果没有大小限制，显然把所有负的集合取走是最优的。

考虑取反权值来求最大值，显然把所有正的取走也是最优的。

现在考虑用网络流来限制 $k = k$。

考虑 $s \stackrel{v_i}{\rightarrow} set_i, set_i \stackrel{inf}{\rightarrow} element_i, element_i \stackrel{0}{\rightarrow} t$。

由于边权不能有负数，考虑给 $v_i$ 加上一个很大的附加权值 $B$，不难发现最小割的总边数恰好是 $n$，这是因为题目里的条件保证了有完美匹配，至少割这么多才合法，而由于边权非负，没有必要割更多，考虑用最小割的二元关系描述，割 $v_i$ 表示不选这个集合，割 $0$ 表示选择这个元素，不难发现，选择的元素 + 不选的集合 = $n$，故合法的最小割一定满足集合和元素个数相同，对 $0$ 也附加权值，这样跑出来的最小割就没有了 $B$ 的影响(恰好是 $nB$)，于是一开始把所有集合权值选上，跑一遍最小割即可。

本题的建模确实非常神仙，看起来比较最大权闭合子图，但又找不到元素的权值，不好切入，需要注意到有完美匹配的二分图如果边权都是非负的，那么最大权闭合子图的含义下可以保证两边元素个数相同。

## CF115E

[cf115e](https://www.luogu.com.cn/problem/CF115E). 

这很网络流，但是 $2e5$ 的数据范围稍微有点让人打退堂鼓。

但是网络流的话，其实没有必要要求选择的区间是连续的，所以这道题应该有更为优秀的做法。

设 $f(i, lst)$ 表示考虑完前 $i$ 个道路，上一次不被选择的点在 $lst$ 的最大权值。

考虑右端点为 $i$ 的所有比赛，相当于区间加，这个位置的选择相当于全局减，$f(i, i)$ 的初始化相当于全局取 $\max$。

所以需要维护区间加，区间求 $\max$，线段树优化即可。

## CF119D

[cf119d](https://www.luogu.com.cn/problem/CF119D). 

考虑先枚举 $i$，此时可以判定前一部分是否可以匹配，一种简单的方法是 hash。

接下来 $j$ 的取值范围可以用 z 函数预处理出来。

具体来说，设 $t = z[i + 1]$，则 $j \in [i + 1, i + t + 1]$，尝试快速的求出最小的 $j$，使得满足匹配。

发现现在的问题变成了两个串，已知两个串前 $z[i + 1]$ 长度匹配，问最小的 $j$，使得后缀反转后和上面的串匹配，且前缀仍处于匹配区间 —— 不难发现取最小的后缀匹配即可，因为前缀的匹配是 **连续的**，所以后缀匹配的越长越好。

等价于求什么呢？

考虑把 $A$ 串反转。

相当于求两个串所有对应前缀的 “border”，这个 border 加引号因为它是 $R_a$ 前缀的前缀和 $B$ 前缀的后缀构成的 border。

所以现在的问题是给你两个串，对于每个前缀 $n$，求出满足 $A[1 \ldots i] = B[n - i +1 \ldots n]$ 的最大的 $i$。

这就是 kmp，直接套上去即可。

这真是一道好题，并不难，但是很考验基础知识的熟练度，以及做题的耐心。

