模拟赛

## A. guard

阿狸桃子弱化，点权看成 $1$，边权看成 $-1$ 即可。

## B. intercept

数据范围明示了矩阵快速幂优化 dp。

设 $f(i, j)$ 表示考虑完前 $i$ 个位置，此时最后一组 `pair` 中靠前的那个位置(或者说左端点最靠后的 `pair`)在 $i - j$ 的方案数，$1 \le j \le m - 1$(0 是不可能做到的)，那么显然 $i - j + 1 \to i$ 这些颜色互不相同，转移可以考虑 $i + 1$ 填甚么，若填后面的某种颜色，则 $j' = j \sim 1$，否则，$j' = j + 1$，但是可选颜色较多。

初始化：`f[1][1] = m, f[1][x] = 0`。

---

`n` 开了 `int`，$100 \to 84$。

## C. raid

答案是 $siz[x] \times sum[x] - v[x] - \sum siz[son] \times sum[son]$，可以考虑预处理一开始的答案，然后维护增量。

考虑子树修改，对于一个子树内的点，修改相当于是：
$$
\begin{align}
&siz[x] \times (v \times siz[x]) - v - \sum siz[son] \times (v \times siz[son])\\
&= (siz^2[x] - \sum siz^2[son] - 1) \times v
\end{align}
$$
所以对每个点预处理 $siz^2[x] - \sum siz^2[son] - 1$ 就可以在线段树上快速维护了。

考虑单点修改，对于这个点，修改相当于是：
$$
(siz[x] - 1) \times v
$$
这可以单独处理。

剩下的问题就是这个点的祖先链的答案如何维护，无论是子树修还是单点修，对于祖先链的影响都可以看作单点修，若为单点修，则令 $d = v$，否则令 $d = siz[x] \times v$，那么修改就是：
$$
siz[anc] \times d - siz[son] \times d
$$
主要难点在于这个 `son` 没法预处理，修改方知我是我。

比较麻烦，考虑拿线段树维护 `sum` 而非 `ans`，这样确实容易很多，但是问题在于怎么求答案，考虑根号分治，对于度数 $\le \sqrt n$ 的查询直接暴力，对于度数 $\gt \sqrt n$ 的点不会超过 $\sqrt n$ 个，直接在线段树上暴力打 `tag`，每个线段树节点维护一下这个区间的超点有哪些，修改到的时候直接暴力 $\ldots$ 等一等，我们怎么知道他的儿子节点是什么的？树剖？等一等，如果是连续区间，显然就是重儿子，否则，最后一个节点的儿子，就是上一层的链头啊？

那直接维护 `ans` 了，树剖的过程中其实告诉了我们 `son` 是谁，于是预处理重儿子 `siz` 即可，每次轻边的那个点单独修改。

---

`sz` 开了 `int`，$100 \to 70$。

## gym102331H

[gym102331h](https://codeforces.com/gym/102331/problem/H). 

硬抗 gym。

Day10 里面已经谈到全局求 $k \in [1, n]$ 的一种方法，可以考虑把分治过程的答案保留下来，求答案的时候类似线段树那么做，把区间提取出来，但是无论如何合并，复杂度总是和区间长度正相关，即使用分治也只能做到 ${\cal O}(nq \log n)$ 的复杂度，但是我们不能学了后面的忘记了前面的，闵和可以在区间长度内求出所有的答案 —— 但是我们现在只要求一个 $k$ 的答案，自然可以 wqs 二分。

后面的先咕了，因为打 cf 了。

