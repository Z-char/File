## CF958E2

[cf958e2](https://www.luogu.com.cn/problem/CF958E2). 

显然不会有长度 $\ge 3$ 的区间，否则缩短合法且答案更优。

这就有一个反悔贪心类似的做法，取点然后把反悔点塞进去，做 $k$ 次，或者由于是反悔贪心了，这玩意是一个凸函数，直接 wqs 套上乱搞即可。

测样例二发现锅了，仔细一看，~~时间不保证有序你恶心谁呢~~？排序即可。

## Luogu5896

[luogu5896](https://www.luogu.com.cn/problem/P5896). 

自然是要在对角线上搞 dp。

发现如果要覆盖 $(r_i, c_i)$ 这个格子，显然至少要覆盖对角线 $\min(r_i, c_i) \to \max(r_i, c_i)$，于是问题转化为，在区间上选至多 $k$ 个线段，每个限制线段至少被一个选择线段完全覆盖，最小化对应的面积并。

经典先把没用的限制去掉，剩下的限制左右端点单调，排序。

最优决策一定是 $[l_1, r_1], [r_1 + 1, r_2] \ldots$ 这样覆盖线段的，设 $f(i, j)$ 表示覆盖前 $i$ 个线段用了 $j$ 个照片的最小代价。

> 发现线段之类的定义有些混用，不过应该可以理解。

转移就是枚举最后一个照片覆盖的线段区间，重复部分非常容易计算，这是因为去掉没用的后这些区间不会有包含，那么倒数第二个照片具体是什么根本不 care，我们显然知道他覆盖的最后一个，因为我们枚举了最后一个的覆盖区间，而这时候交就容易计算了，其实就是他的最后一个和我的第一个线段交，于是设 $g(i)$ 表示第 $i$ 条线段和 $i - 1$ 线段的交的平方，就有转移：
$$
f(i) = \min(f(j - 1) + (r_i - l_j + 1)^2 - g(j))
$$

> 对于 $g$ 显然有：$g(i) = \max(r_{i - 1} - l_i + 1, 0) ^ 2$。
>
> 这里省略了段数维度，$f$ 的段数从 $k - 1 \to k$。

那这是经典的斜率优化，直接套上去可以做到 $nm$。

~~但是数据范围实在是太大了~~。

显然第一维不能干掉，第二维的话，划分为 $k$ 段可以想到 wqs 二分，直接套 wqs 二分即可。

> 猜测是凸的，猜测选的越多答案越难优化。

因为保证了 $k \le n$(好吧，如果不保证就是显然的贪心了)，不难发现选的越多答案越优，所以可以认为就是恰好选 $k$ 个。

最后就是经典注意事项了，三点共线？

段数少才能更新答案，转移过程中越少越好，即同斜率最左点即可。

