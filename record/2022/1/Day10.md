模拟赛：

## A. set

考虑 $62$ 位，如果这一位为 $1$ 的是偶数个，那么我们一定存在一个这一位进位的方案(除了 0)，否则如果是奇数个，那么这一位恰好只会贡献一次。

---

考虑求出总的异或和 $s$，更形式化的审视上面的性质：

1. 若这一位 $s$ 为 $1$，则 $x_1$ 和 $x_2$ 一定一个为 $0$ 一个为 $1$，因为无论如何这一位贡献不变，恰好贡献一次，所以 $x_1$ 选 $0$ 更优。
2. 若这一位 $s$ 为 $0$，则 $x_1, x_2$ 尽量这一位都是 $1$。

一般的线性基是从高位到低位贪心，这是为了保证尽量大。

但是特别的，我们这里的要求是 $0$ 位有贡献，$1$ 位没有贡献，所以应该优先按照 $0$ 位贪心插入，选的时候也优先按照 $0$ 位贪心选，最大化 $x_2$ 就是最小化 $x_1$。

## B. string

sam 拼拼数计计。

## C. second

考虑两子树相同等价于按某种特定顺序书写 $k - 1$ 子树里的点的儿子个数的序列相同，本质不同的儿子个数只有 $\sqrt n$ 级别，可以尝试 hash，bfs 序应该是可以做到 $n^2$。

---

考虑让树和其括号序列建立双射，二分 $k$ 去判定，发现一个点对应的 hash 区间是自己对应的括号序删除那些 $k + 1$ 深度儿子的区间，那么将一个点的标记打到 $k + 1$ 级父亲上，查询的时候暴力查找所有标记，删除这些区间，暴力合并 hash 值即可，均摊为 ${\cal O}(n)$，总复杂度为 ${\cal O}(n \log n)$。

## CF280D

[cf280d](https://www.luogu.com.cn/problem/CF280D). 

这是一道经典的模拟费用流题，不难建立费用流模型，线段树可以容易的维护。

当然，这里把它拿出来当然不是为了探讨如何用线段树做。

考虑单组全局询问，因为这是个费用流题，所以一定满足凸性，故可以使用 wqs 二分来处理。

设 $f(i)$ 表示考虑前 $i$ 个时候的最大子段和，那么：
$$
f(i) = \max_{j\lt i} f(j) + s(i) - s(j) - del
$$
单调队列优化即可做到 ${\cal O}(n \log w)$ 的复杂度。

但是，倘若我们要求出所有 $k \in [1, n]$ 的答案呢？

此时一个个的二分过去复杂度是 ${\cal O}(n^2 \log w)$，线段树做法也是 ${\cal O}(n^2 \log n)$ 级别的，那怎么办呢？

一个虽然 naive 但是很奇怪的 dp 是设 $f(l, r, k, 0/1, 0/1)$ 表示 $[l, r]$ 区间选了 $k$ 段此时左端点是否被选择，右端点是否被选择的最大价值和。

后面两维的意义在于区间合并时可能会有 $k_1, k_2 \to k_1 + k_2 - 1$，即中间选择了一大段。

直接暴力做是 ${\cal O}(n^3)$ 的，之所以不是 ${\cal O}(n^4)$ 是因为我们不需要枚举中间的分割点，随便选一个即可，因为我们的 dp 本身就支持合并，而答案无外乎就是两种，一种是分割点两端递归，一种是两边合并起来，所以随便挑一个分割点即可，故转移复杂度为 ${\cal O}(1)$，总复杂度为 ${\cal O}(n^3)$。

考虑猫老师所说的 "将键值函数化"，对于 $f_{l, r, 0/1, 0/1}(k)$ 这个函数，这是一个凸函数。

> 怎么维护这个函数？
>
> 暴力维护 $n$ 个点的点值即可。

注意到转移形如 $f_{l, p, a, b}(k_1) + f_{p + 1, r, c, d}(k_2) \to f_{l, r, a, d}(k_1 + k_2)$ —— 虽然有一些转移到 $k_1 + k_2 - 1$，但是无所谓，平移一下即可。

回忆一下闵科夫斯基和 $(a, b) + (c, d) \to (a + c, b + d)$ —— 两个凸包上点的相加，如果省略去下标并添入一维，其实可以看作转移 $(k_1, f(k_1)) + (k_2, f(k_2)) \to (k_1 + k_2, f(k_1) + f(k_2))$，由于 $f$ 是凸函数，可以用闵科夫斯基和在 ${\cal O}(r - l)$ (因为长度为 $r - l$ 的区间最多划分 $r - l$ 段，而闵科夫斯基和复杂度为点数/边数)的复杂度内完成，枚举 $a, b, c, d$ 后每次做一遍闵科夫斯基和，对于 $k_1 + k_2 - 1$ 再做一次然后每个位置对应求最大值，由于一般省略常数，所以可以认为是 ${\cal O}(r - l)$ 的 —— 这就是归并排序的复杂度分析了，我们取分割点 $p$ 为 $[l, r]$ 中点，总复杂度为 ${\cal O}(n \log n)$，于是我们在 ${\cal O}(n \log n)$ 的复杂度内求出了 $k \in [1, n]$ 的答案。

因为没有找到合适的题，所以没有写代码，咕掉了。

