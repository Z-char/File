## Luogu7985

[luogu7985](https://www.luogu.com.cn/problem/P7985). 

不管是 `G` 还是 `P`，$T = 1$ 都相对简单，因为最大化匹配就不用考虑配对极大的限制了，因为答案一定是某个极大匹配。

设 $f(i, j)$ 表示匹配了前 $i$ 个 `H` 以及前 $j$ 个 `G` 的最大匹配，转移就类似 `lcs` 即可。

至于 $T = 2$，配对极大是一个很麻烦的限制，考虑把它扔到状态里，发现只需要记录最后一头未匹配牛即可，若新牛和之前牛匹配，显然这头牛直接就匹配了(不管是匹配谁)，那么设 $f(i, j, k)$ 转移即可，转移还是考虑同时走，舍弃 $i$ 以及舍弃 $j$，但是此时的舍弃 $i, j$ 是有条件的，即不能和上一次的 $k$ 匹配，另外，若其余的无法完成匹配，自然无法到最后的 $f(A, B, ?)$ 状态，故可以保证完成极大匹配，缺点是时间复杂度为 ${\cal O}(n^3)$，无法通过。

考虑优化状态，设 $f(i, j, 0/1)$ 表示匹配到 $i, j$，下一头是 $0/1$ 牛可以保证匹配，或者说我们钦定了下一头是什么牛。

有转移 $f(i, j, x) \to f(i + 1, j + 1, x), f(i, j, 0) \to f(i + 1, j, 0), f(i, j, 1) \to f(i, j + 1, 1)$。

然而显然是错的，确实是可以保证匹配，也可以保证剩下的匹配(否则达不到最终状态)，但是仅仅保证了极大，没有保证求得答案最优，这样的转移限定了选的牛是同一种，故而寄了。

于是我们需要一种转移，可以在 $f(i, j, 0)$ 和 $f(i, j, 1)$ 间互相转移。

考虑 $f(i, j, 0)$，此时最后一只未匹配牛可能是 $i$，那么考虑 $i$ 不能匹配的第一只牛，不妨设为 $j + len + 1$，那么若 $i + 1 \to i + len$ 能和 $j + 1 \to j + len$ 完全匹配，就可以转移到 $f(i + len, j + len, 1)$，那么 $1 \to 0$ 是同理的。

`nxt` 是不难处理的(不能匹配的第一只牛)，至于怎么判断，可以预处理 `mth[i][j]` 表示 $i, j$ 开始匹配的最长匹配段。

至于匹配更长一段显然没必要，可以转移过去，至于 $i$ 可能不是非匹配牛，这也不重要，因为不会影响最值，因为考虑最优方案的选择，一定存在一种方案，每次都从非匹配牛改变，故答案不会变劣，而且他不会更优，因为他并没有贡献权值，只是匹配了一段而已，完全可以从非匹配牛改变，然后往后推进到这个状态，故不影响答案。

